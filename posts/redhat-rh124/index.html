<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta name="generator" content="Hugo 0.81.0" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redhat RH124 | FXSHELL</title>
    <meta name="description" content="Red Hat System Administration I O curso Red Hat System Administration I (RH124) foi desenvolvido para profissionais de TI sem experiência anterior em administração de sistemas Linux. O recurso tem como objetivo fornecer aos alunos &ldquo;habilidades de sobrevivência&rdquo; de administração do Linux, com foco em tarefas centrais de administração. O Red Hat System Administration I também oferece uma base para os alunos que planejam se tornar administradores de sistemas Linux em tempo integral, apresentando os principais conceitos de linha de comando e ferramentas de nível corporativo.">
    <meta name="keywords" content="">
    
    
    
    
    

  <meta name="author" content="">


    <meta property="og:title" content="Redhat RH124" />
<meta property="og:description" content="Red Hat System Administration I O curso Red Hat System Administration I (RH124) foi desenvolvido para profissionais de TI sem experiência anterior em administração de sistemas Linux. O recurso tem como objetivo fornecer aos alunos &ldquo;habilidades de sobrevivência&rdquo; de administração do Linux, com foco em tarefas centrais de administração. O Red Hat System Administration I também oferece uma base para os alunos que planejam se tornar administradores de sistemas Linux em tempo integral, apresentando os principais conceitos de linha de comando e ferramentas de nível corporativo." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/redhat-rh124/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-16T23:03:55-03:00" />
<meta property="article:modified_time" content="2021-03-16T23:03:55-03:00" />


    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Redhat RH124"/>
<meta name="twitter:description" content="Red Hat System Administration I O curso Red Hat System Administration I (RH124) foi desenvolvido para profissionais de TI sem experiência anterior em administração de sistemas Linux. O recurso tem como objetivo fornecer aos alunos &ldquo;habilidades de sobrevivência&rdquo; de administração do Linux, com foco em tarefas centrais de administração. O Red Hat System Administration I também oferece uma base para os alunos que planejam se tornar administradores de sistemas Linux em tempo integral, apresentando os principais conceitos de linha de comando e ferramentas de nível corporativo."/>

    




    

    
    
  <meta name="referrer" content="same-origin">


    

    
    <link rel="canonical" href="/posts/redhat-rh124/">
    
    
    <link rel="icon" sizes="any" href="data:image/svg+xml,%3Csvg%20viewBox='0%200%2046%2045'%20xmlns='http://www.w3.org/2000/svg'%3E%3Ctitle%3EAfter%20Dark%3C/title%3E%3Cpath%20d='M.708%2045L23%20.416%2045.292%2045H.708zM35%2038L23%2019%2011%2038h24z'%20fill='%23000'/%3E%3C/svg%3E">

    

  
  
  
  
  
  
  
    
      
        <style>html{font-size:12px}*{box-sizing:border-box;text-rendering:geometricPrecision}body{font-size:1rem;line-height:1.5rem;margin:0;font-family:Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,serif;word-wrap:break-word}h1,h2,h3,h4,h5,h6{line-height:1.3em}fieldset{border:none;padding:0;margin:0}pre{padding:2rem;margin:1.75rem 0;background-color:#fff;border:1px solid #ccc;overflow:auto}code[class*=language-],pre[class*=language-],pre code{font-weight:100;text-shadow:none;margin:1.75rem 0}a{cursor:pointer;color:#ff2e88;text-decoration:none;border-bottom:1px solid #ff2e88}a:hover{background-color:#ff2e88;color:#fff}.grid{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap}.grid.\-top{-ms-flex-align:start;align-items:flex-start}.grid.\-middle{-ms-flex-align:center;align-items:center}.grid.\-bottom{-ms-flex-align:end;align-items:flex-end}.grid.\-stretch{-ms-flex-align:stretch;align-items:stretch}.grid.\-baseline{-ms-flex-align:baseline;align-items:baseline}.grid.\-left{-ms-flex-pack:start;justify-content:flex-start}.grid.\-center{-ms-flex-pack:center;justify-content:center}.grid.\-right{-ms-flex-pack:end;justify-content:flex-end}.grid.\-between{-ms-flex-pack:justify;justify-content:space-between}.grid.\-around{-ms-flex-pack:distribute;justify-content:space-around}.cell{-ms-flex:1;flex:1;box-sizing:border-box}@media screen and (min-width:768px){.cell.\-1of12{-ms-flex:0 0 8.33333%;flex:0 0 8.33333%}.cell.\-2of12{-ms-flex:0 0 16.66667%;flex:0 0 16.66667%}.cell.\-3of12{-ms-flex:0 0 25%;flex:0 0 25%}.cell.\-4of12{-ms-flex:0 0 33.33333%;flex:0 0 33.33333%}.cell.\-5of12{-ms-flex:0 0 41.66667%;flex:0 0 41.66667%}.cell.\-6of12{-ms-flex:0 0 50%;flex:0 0 50%}.cell.\-7of12{-ms-flex:0 0 58.33333%;flex:0 0 58.33333%}.cell.\-8of12{-ms-flex:0 0 66.66667%;flex:0 0 66.66667%}.cell.\-9of12{-ms-flex:0 0 75%;flex:0 0 75%}.cell.\-10of12{-ms-flex:0 0 83.33333%;flex:0 0 83.33333%}.cell.\-11of12{-ms-flex:0 0 91.66667%;flex:0 0 91.66667%}}@media screen and (max-width:768px){.grid{-ms-flex-direction:column;flex-direction:column}.cell{-ms-flex:0 0 auto;flex:0 0 auto}}.hack,.hack blockquote,.hack code,.hack em,.hack h1,.hack h2,.hack h3,.hack h4,.hack h5,.hack h6,.hack strong{font-size:1rem;font-style:normal;font-family:Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,serif}.hack blockquote,.hack code,.hack em,.hack strong{line-height:20px}.hack blockquote,.hack code,.hack footer,.hack h1,.hack h2,.hack h3,.hack h4,.hack h5,.hack h6,.hack header,.hack li,.hack ol,.hack p,.hack section,.hack ul{float:none;margin:0;padding:0}.hack blockquote,.hack h1,.hack ol,.hack p,.hack ul{margin-top:20px;margin-bottom:20px}.hack h1{position:relative;display:inline-block;display:table-cell;padding:20px 0 30px;margin:0;overflow:hidden}.hack h1:after{content:"====================================================================================================";position:absolute;bottom:10px;left:0}.hack h1+*{margin-top:0}.hack h2,.hack h3,.hack h4,.hack h5,.hack h6{position:relative;margin-bottom:1.75rem}.hack h2:before,.hack h3:before,.hack h4:before,.hack h5:before,.hack h6:before{display:inline}.hack h2:before{content:"## "}.hack h3:before{content:"### "}.hack h4:before{content:"#### "}.hack h5:before{content:"##### "}.hack h6:before{content:"###### "}.hack li{position:relative;display:block;padding-left:20px}.hack li:after{position:absolute;top:0;left:0}.hack ul>li:after{content:"-"}.hack ol{counter-reset:a}.hack ol>li:after{content:counter(a) ".";counter-increment:a}.hack ol li:nth-child(n+10):after{left:-7px}.hack blockquote{position:relative;padding-left:17px;padding-left:2ch;overflow:hidden}.hack blockquote:after{content:">\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>";white-space:pre;position:absolute;top:0;left:0;line-height:20px}.hack em:after,.hack em:before{content:"*";display:inline}.hack pre code:after,.hack pre code:before{content:""}.hack code{font-weight:700}.hack code:after,.hack code:before{content:"`";display:inline}.hack hr{position:relative;height:20px;overflow:hidden;border:0;margin:20px 0}.hack hr:after{content:"----------------------------------------------------------------------------------------------------";position:absolute;top:0;left:0;line-height:20px;width:100%;word-wrap:break-word}@-moz-document url-prefix(){.hack h1{display:block}}.hack-ones ol>li:after{content:"1."}p{margin:0 0 1.75rem}.container{max-width:70rem}.container,.container-fluid{margin:0 auto;padding:0 1rem}.inner{padding:1rem}.inner2x{padding:2rem}.pull-left{float:left}.pull-right{float:right}.progress-bar{height:8px;opacity:.8;background-color:#ccc;margin-top:12px}.progress-bar.progress-bar-show-percent{margin-top:38px}.progress-bar-filled{background-color:gray;height:100%;transition:width .3s ease;position:relative;width:0}.progress-bar-filled:before{content:"";border:6px solid transparent;border-top-color:gray;position:absolute;top:-12px;right:-6px}.progress-bar-filled:after{color:gray;content:attr(data-filled);display:block;font-size:12px;white-space:nowrap;position:absolute;border:6px solid transparent;top:-38px;right:0;-ms-transform:translateX(50%);transform:translateX(50%)}table{width:100%;border-collapse:collapse;margin:1.75rem 0;color:#778087}table td,table th{vertical-align:top;border:1px solid #ccc;line-height:15px;padding:10px}table thead th{font-size:10px}table tbody td:first-child{font-weight:700;color:#333}.form{width:30rem}.form-group{margin-bottom:1.75rem;overflow:auto}.form-group label{border-bottom:2px solid #ccc;color:#333;width:10rem;display:inline-block;height:38px;line-height:38px;padding:0;float:left;position:relative}.form-group.form-success label{color:#4caf50!important;border-color:#4caf50!important}.form-group.form-warning label{color:#ff9800!important;border-color:#ff9800!important}.form-group.form-error label{color:#f44336!important;border-color:#f44336!important}.form-control{outline:none;border:none;border-bottom:2px solid #ccc;padding:.5rem 0;width:20rem;height:38px;background-color:transparent}.form-control:focus{border-color:#555}.form-group.form-textarea label:after{position:absolute;content:"";width:2px;background-color:#fff;right:-2px;top:0;bottom:0}textarea.form-control{height:auto;resize:none;padding:1rem 0;border-bottom:2px solid #ccc;border-left:2px solid #ccc;padding:.5rem}select.form-control{border-radius:0;background-color:transparent;-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none}.help-block{color:#999;margin-top:.5rem}.form-actions{margin-bottom:1.75rem}.btn{display:-ms-inline-flexbox;display:inline-flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;cursor:pointer;outline:none;padding:.65rem 2rem;font-size:1rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;z-index:1}.btn:active{box-shadow:inset 0 1px 3px rgba(0,0,0,.12)}.btn.btn-ghost{border-color:#757575;color:#757575;background-color:transparent}.btn.btn-ghost:focus,.btn.btn-ghost:hover{border-color:#424242;color:#424242;z-index:2}.btn.btn-ghost:hover{background-color:transparent}.btn-block{width:100%;display:-ms-flexbox;display:flex}.btn-default{color:#fff;background-color:#e0e0e0;border:1px solid #e0e0e0;color:#333}.btn-default:focus:not(.btn-ghost),.btn-default:hover{background-color:#dcdcdc;border-color:#dcdcdc}.btn-success{color:#fff;background-color:#4caf50;border:1px solid #4caf50}.btn-success:focus:not(.btn-ghost),.btn-success:hover{background-color:#43a047;border-color:#43a047}.btn-success.btn-ghost{border-color:#4caf50;color:#4caf50}.btn-success.btn-ghost:focus,.btn-success.btn-ghost:hover{border-color:#388e3c;color:#388e3c;z-index:2}.btn-error{color:#fff;background-color:#f44336;border:1px solid #f44336}.btn-error:focus:not(.btn-ghost),.btn-error:hover{background-color:#e53935;border-color:#e53935}.btn-error.btn-ghost{border-color:#f44336;color:#f44336}.btn-error.btn-ghost:focus,.btn-error.btn-ghost:hover{border-color:#d32f2f;color:#d32f2f;z-index:2}.btn-warning{color:#fff;background-color:#ff9800;border:1px solid #ff9800}.btn-warning:focus:not(.btn-ghost),.btn-warning:hover{background-color:#fb8c00;border-color:#fb8c00}.btn-warning.btn-ghost{border-color:#ff9800;color:#ff9800}.btn-warning.btn-ghost:focus,.btn-warning.btn-ghost:hover{border-color:#f57c00;color:#f57c00;z-index:2}.btn-info{color:#fff;background-color:#00bcd4;border:1px solid #00bcd4}.btn-info:focus:not(.btn-ghost),.btn-info:hover{background-color:#00acc1;border-color:#00acc1}.btn-info.btn-ghost{border-color:#00bcd4;color:#00bcd4}.btn-info.btn-ghost:focus,.btn-info.btn-ghost:hover{border-color:#0097a7;color:#0097a7;z-index:2}.btn-primary{color:#fff;background-color:#2196f3;border:1px solid #2196f3}.btn-primary:focus:not(.btn-ghost),.btn-primary:hover{background-color:#1e88e5;border-color:#1e88e5}.btn-primary.btn-ghost{border-color:#2196f3;color:#2196f3}.btn-primary.btn-ghost:focus,.btn-primary.btn-ghost:hover{border-color:#1976d2;color:#1976d2;z-index:2}.btn-group{overflow:auto}.btn-group .btn{float:left}.btn-group .btn-ghost:not(:first-child){margin-left:-1px}.card{border:1px solid #ccc}.card .card-header{color:#333;text-align:center;background-color:#ddd;padding:.5rem 0}.alert{color:#ccc;padding:1rem;border:1px solid #ccc;margin-bottom:1.75rem}.alert-success{color:#4caf50;border-color:#4caf50}.alert-error{color:#f44336;border-color:#f44336}.alert-info{color:#00bcd4;border-color:#00bcd4}.alert-warning{color:#ff9800;border-color:#ff9800}.media:not(:last-child){margin-bottom:1.25rem}.media-left{padding-right:1rem}.media-left,.media-right{display:table-cell;vertical-align:top}.media-right{padding-left:1rem}.media-body{display:table-cell;vertical-align:top}.media-heading{font-size:1.16667rem;font-weight:700}.media-content{margin-top:.3rem}.avatarholder,.placeholder{background-color:#f0f0f0;text-align:center;color:#b9b9b9;font-size:1rem;border:1px solid #f0f0f0}.avatarholder{width:48px;height:48px;line-height:46px;font-size:2rem;background-size:cover;background-position:50%;background-repeat:no-repeat}.avatarholder.rounded{border-radius:33px}.loading{display:inline-block;content:"&nbsp;";height:20px;width:20px;margin:0 .5rem;animation:a .6s infinite linear;border:2px solid #e91e63;border-right-color:transparent;border-radius:50%}.btn .loading{margin-bottom:0;width:14px;height:14px}.btn div.loading{float:left}.alert .loading{margin-bottom:-5px}@keyframes a{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.menu{width:100%}.menu .menu-item{display:block;color:#616161;border-color:#616161}.menu .menu-item.active,.menu .menu-item:hover{color:#000;border-color:#000;background-color:transparent}@media screen and (max-width:768px){.form-group label{display:block;border-bottom:none;width:100%}.form-group.form-textarea label:after{display:none}.form-control{width:100%}textarea.form-control{border-left:none;padding:.5rem 0}pre::-webkit-scrollbar{height:3px}}@media screen and (max-width:480px){.form{width:100%}}.dark{color:#ccc}.dark,.dark pre{background-color:#000}.dark pre{padding:0;border:none}.dark pre code{color:#00bcd4}.dark h1 a,.dark h2 a,.dark h3 a,.dark h4 a,.dark h5 a{color:#ccc}.dark code,.dark strong{color:#fff}.dark code{font-weight:100}.dark table{color:#ccc}.dark table td,.dark table th{border-color:#444}.dark table tbody td:first-child{color:#fff}.dark .form-group label{color:#ccc;border-color:rgba(95,95,95,.78)}.dark .form-group.form-textarea label:after{background-color:#000}.dark .form-control{color:#ccc;border-color:rgba(95,95,95,.78)}.dark .form-control:focus{border-color:#ccc;color:#ccc}.dark textarea.form-control{color:#ccc}.dark .card{border-color:rgba(95,95,95,.78)}.dark .card .card-header{background-color:transparent;color:#ccc;border-bottom:1px solid rgba(95,95,95,.78)}.dark .btn.btn-ghost.btn-default{border-color:#ababab;color:#ababab}.dark .btn.btn-ghost.btn-default:focus,.dark .btn.btn-ghost.btn-default:hover{border-color:#9c9c9c;color:#9c9c9c;z-index:1}.dark .btn.btn-ghost.btn-default:focus,.dark .btn.btn-ghost.btn-default:hover{border-color:#e0e0e0;color:#e0e0e0}.dark .btn.btn-ghost.btn-primary:focus,.dark .btn.btn-ghost.btn-primary:hover{border-color:#64b5f6;color:#64b5f6}.dark .btn.btn-ghost.btn-success:focus,.dark .btn.btn-ghost.btn-success:hover{border-color:#81c784;color:#81c784}.dark .btn.btn-ghost.btn-info:focus,.dark .btn.btn-ghost.btn-info:hover{border-color:#4dd0e1;color:#4dd0e1}.dark .btn.btn-ghost.btn-error:focus,.dark .btn.btn-ghost.btn-error:hover{border-color:#e57373;color:#e57373}.dark .btn.btn-ghost.btn-warning:focus,.dark .btn.btn-ghost.btn-warning:hover{border-color:#ffb74d;color:#ffb74d}.dark .avatarholder,.dark .placeholder{background-color:transparent;border-color:#333}.dark .menu .menu-item{color:#ccc;border-color:rgba(95,95,95,.78)}.dark .menu .menu-item.active,.dark .menu .menu-item:hover{color:#fff;border-color:#ccc}:root{--screen-size-small:30em}@keyframes intro{0%{opacity:0}; 100%{opacity:1}}.blur-up{-webkit-filter:blur(5px);filter:blur(5px);transition:filter 400ms,-webkit-filter 400ms}.blur-up.lazyloaded{-webkit-filter:blur(0);filter:blur(0)}.hack .readmore{margin-bottom:2.2em}.responsive-iframe{position:relative;padding-bottom:56.25%;padding-top:25px;height:0}.responsive-iframe iframe{position:absolute;top:0;left:0;width:100%;height:100%}iframe{border:0}main,footer{animation:intro .3s both;animation-delay:.15s}footer time[datetime$=M]:before{content:"\2013\0020"}@media only screen and (max-width:30em){footer time[datetime$=M]{display:none}}blockquote cite{display:block}blockquote cite::before{content:"\2014"}:target{color:#fff}.hack li ul{margin:0}.main{padding:20px 10px}input.form-control{border-radius:0;background-color:initial;-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none}input.form-control,textarea.form-control{font-size:initial}.hack .help-block{font-size:1rem}html{font-size:13px}.hack pre{font-size:17px}.hack .form input,.hack .form textarea,.hack .form button,.hack .form label{font-size:1rem}article [itemprop=description]{margin-bottom:20px;margin-top:20px}article header img{width:100%;border-radius:3px}table td,table th{line-height:inherit}img{max-width:100%}@media screen and (min-width:768px){html{font-size:1em}.container{max-width:50rem}}[v-cloak]{display:none}a[rel*="external"]::after {
  content: " " url("data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20class='i-external'%20viewBox='0%200%2032%2032'%20width='14'%20height='14'%20fill='none'%20stroke='%23ff9800'%20stroke-linecap='round'%20stroke-linejoin='round'%20stroke-width='9.38%'%3E%3Cpath%20d='M14%209%20L3%209%203%2029%2023%2029%2023%2018%20M18%204%20L28%204%2028%2014%20M28%204%20L14%2018'/%3E%3C/svg%3E");
}
nav a.active {
  background-color: #ff2e88;
  color: #fff;
}
a[itemprop="url"] {
  color: #ff9800;
}
a[itemprop="url"]:hover {
  color: #fff;
}
.muted, .help-block {
  opacity: 0.70;
}
.hack .muted,
.hack .help-block {
  color: #e0e0e0;
}
</style>
        


  
    <meta name="theme-color" content=#000>
  


      
    
  


    <script>
 
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.fetchInject=t()}(this,function(){"use strict";const e=function(e,t,n,r,o,c,i){c=t.createElement(n),i=t.getElementsByTagName(n)[0],c.appendChild(t.createTextNode(r.text)),c.onload=o(r),i?i.parentNode.insertBefore(c,i):t.head.appendChild(c)};return function(t,n){if(!arguments.length)return Promise.reject(new ReferenceError("Failed to execute 'fetchInject': 1 argument required but only 0 present."));if(arguments[0]&&arguments[0].constructor!==Array)return Promise.reject(new TypeError("Failed to execute 'fetchInject': argument 1 must be of type 'Array'."));if(arguments[1]&&arguments[1].constructor!==Promise)return Promise.reject(new TypeError("Failed to execute 'fetchInject': argument 2 must be of type 'Promise'."));const r=[],o=n?[].concat(n):[],c=[];return t.forEach(e=>o.push(window.fetch(e).then(e=>[e.clone().text(),e.blob()]).then(e=>Promise.all(e).then(e=>{r.push({text:e[0],blob:e[1]})})))),Promise.all(o).then(()=>(r.forEach(t=>{c.push({then:n=>{t.blob.type.includes("text/css")?e(window,document,"style",t,n):e(window,document,"script",t,n)}})}),Promise.all(c)))}});
fetchInject(["/js/lazysizes.min.js"]);
</script>

    <style>
  img {
    max-width: 100%;
  }
</style>

    
    
      <script>fetchInject(["/css/syntax.css"])</script>

      
      <script type="text/javascript" async
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [['$','$'], ['\\(','\\)']],
          displayMath: [['$$','$$']],
          processEscapes: true,
          processEnvironments: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
          TeX: { equationNumbers: { autoNumber: "AMS" },
              extensions: ["AMSmath.js", "AMSsymbols.js"] }
        }
        });
        MathJax.Hub.Queue(function() {
          
          
          
          var all = MathJax.Hub.getAllJax(), i;
          for(i = 0; i < all.length; i += 1) {
              all[i].SourceElement().parentNode.className += ' has-jax';
          }
        });

        MathJax.Hub.Config({
        
        TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

      <noscript>
        <link href=/css/syntax.css rel="stylesheet">
      </noscript>
    
  </head>
  
  
  
  <body class="hack dark main container">
    <header>
  
  <nav itemscope itemtype="http://schema.org/SiteNavigationElement">
    
    
      <a itemprop="url" class="" href="/"><span itemprop="name">home</span></a>
    
      <a itemprop="url" class="" href="/posts/"><span itemprop="name">anotações</span></a>
    
      <a itemprop="url" class="" href="/htb/"><span itemprop="name">HTB</span></a>
    
      <a itemprop="url" class="" href="/sobre"><span itemprop="name">sobre</span></a>
    
  </nav>


</header>
    <main>
  <header>
    <h1>Redhat RH124</h1>
  </header>
  <p><img src="/redhat0.png" alt="HTB"></p>
<h2 id="red-hat-system-administration-i">Red Hat System Administration I</h2>
<p>O curso Red Hat System Administration I (RH124) foi desenvolvido para profissionais de TI sem experiência anterior em administração de sistemas Linux. O recurso tem como objetivo fornecer aos alunos &ldquo;habilidades de sobrevivência&rdquo; de administração do Linux, com foco em tarefas centrais de administração. O Red Hat System Administration I também oferece uma base para os alunos que planejam se tornar administradores de sistemas Linux em tempo integral, apresentando os principais conceitos de linha de comando e ferramentas de nível corporativo. Esses conceitos serão mais desenvolvidos no próximo curso, Red Hat System Administration II (RH134).</p>
<h2 id="fedora">Fedora</h2>
<p>Fedora é um projeto comunitário que produz e lança um sistema operacional completo, gratuito e baseado em Linux. A Red Hat patrocina a comunidade e trabalha com representantes da comunidade para integrar o mais recente software upstream a uma distribuição rápida e segura. O projeto Fedora contribui com tudo de volta para o mundo open source livre, e qualquer pessoa pode participar.</p>
<p>No entanto, o Fedora se concentra na inovação e na excelência, e não na estabilidade de longo prazo. Novas atualizações importantes acontecem a cada seis meses e podem trazer mudanças significativas. O Fedora é compatível somente com lançamentos por cerca de um ano (duas atualizações principais), o que o torna menos adequado para uso empresarial.</p>
<h2 id="red-hat-enterprise-linux">Red Hat Enterprise Linux</h2>
<p>O Red Hat Enterprise Linux (RHEL) é a distribuição do Linux da Red Hat pronta para empresas e com suporte comercial. É a plataforma líder para computação open source, não apenas uma coleção de projetos open source maduros. O RHEL é extensivamente testado, tem um grande ecossistema de suporte de parceiros, certificações de hardware e software, serviços de consultoria, treinamento e suporte de vários anos e garantias de manutenção.</p>
<p>A Red Hat baseia suas principais versões do RHEL no Fedora. No entanto, em função disso, a Red Hat pode escolher quais pacotes incluir, fazer outras melhorias (contribuiu com os projetos de upstream e Fedora) e tomar decisões de configuração que atendam às necessidades dos clientes. A Red Hat ajuda os fornecedores e clientes a se envolverem com a comunidade de open source e a trabalhar com o desenvolvimento upstream para desenvolver soluções e corrigir problemas.</p>
<p>O Red Hat Enterprise Linux usa um modelo de distribuição baseado em subscrição. Como este é um software open source, esta não é uma taxa de licença. Em vez disso, ela paga o suporte, a manutenção, as atualizações, patches de segurança, acesso à base de conhecimento no Red Hat Customer Portal (<a href="http://access.redhat.com/),">http://access.redhat.com/),</a> certificações e assim por diante. O cliente está pagando por suporte e expertise de longo prazo, comprometimento e assistência quando necessário.</p>
<p>Quando grandes atualizações são disponibilizadas, os clientes podem implementá-las quando for mais conveniente para eles e sem pagar mais. Isso simplifica o gerenciamento das atualizações de sistema nos aspectos econômico e prático.</p>
<h2 id="centos">CentOS</h2>
<p>O CentOS é uma distribuição Linux orientada pela comunidade e derivada em grande parte da base de código open source da Red Hat Enterprise Linux e outras fontes. É gratuito, fácil de instalar e conta com equipe e suporte de uma comunidade ativa de voluntários que opera independentemente da Red Hat.</p>
<h2 id="introdução-ao-ambiente-gnome-de-área-de-trabalho">Introdução ao ambiente GNOME de área de trabalho</h2>
<p>O ambiente de desktop é a interface gráfica do usuário em um sistema Linux. O ambiente de área de trabalho padrão no Red Hat Enterprise Linux 8 é fornecido pelo GNOME 3. Ele fornece aos usuários uma área de trabalho integrada, além de uma plataforma de desenvolvimento unificada fornecida pelo Wayland (por padrão) ou pelo X Window System legado.</p>
<p>O GNOME Shell oferece as principais funções de interface de usuário do ambiente GNOME de área de trabalho. O aplicativo GNOME Shell é altamente personalizável. O padrão do Red Hat Enterprise Linux 8 para a aparência do GNOME Shell é o tema &ldquo;Padrão&rdquo;, que é usado nesta seção. O padrão do Red Hat Enterprise Linux 7 era um tema alternativo chamado &ldquo;Clássico&rdquo;, que estava mais perto da aparência de versões mais antigas do GNOME. O tema pode ser selecionado de modo persistente no login, clicando o ícone de engrenagem ao lado do botão Sign In depois de selecionar a conta e antes de digitar a senha.</p>
<p><img src="/1h.png" alt="HTB"></p>
<h2 id="partes-do-gnome-shell">Partes do GNOME Shell</h2>
<p>Os elementos do GNOME Shell incluem as seguintes partes, conforme ilustrado por esta captura de tela do GNOME Shell no modo de visão geral Activities:</p>
<p><img src="/2h.png" alt="HTB"></p>
<ol>
<li>
<p>Barra superior: a barra que fica no topo da tela. Ela é exibido na visão geral Activities e nos espaços de trabalho. A barra superior oferece o botão Activities, além dos controles de volume, rede, acesso ao calendário e a alternância entre os métodos de entrada de teclado (se mais de uma estiver configurada).</p>
</li>
<li>
<p>Activities overview: este é um modo especial que ajuda um usuário a organizar janelas e iniciar aplicativos. A visão geral Activities pode ser inserida clicando no botão Activities no canto superior esquerdo da barra superior ou pressionando a tecla Super. A tecla Super (às vezes chamada de tecla do Windows ou a tecla Command), fica perto do canto inferior esquerdo de um PC IBM de 104/105 teclas ou de um teclado Apple. As três áreas principais da visão geral Activities são o dash, à esquerda da tela, a windows overview, no centro da tela, e o workspace selector, no lado direito da tela.</p>
</li>
<li>
<p>System menu: o menu no canto superior direito na barra superior fornece controle para ajustar o brilho da tela e para ativar ou desativar as conexões de rede. Abaixo do submenu do nome de usuário estão as opções para ajustar das configurações de conta e fazer o logout do sistema ou desligar. O menu do sistema também oferece botões para abrir a janela Settings, bloquear a tela ou desligar o sistema.</p>
</li>
<li>
<p>Dash: é uma lista configurável de ícones dos aplicativos favoritos do usuário, dos aplicativos que estão em execução e um botão de grid na parte inferior do dash que pode ser usado para selecionar aplicativos arbitrários. Você pode iniciar os aplicativos clicando em um dos ícones ou usando a grade para encontrar um aplicativo menos usado. O dash também é, às vezes, chamado de dock.</p>
</li>
<li>
<p>Windows overview: uma área no centro da visão geral Activities, que exibe miniaturas de todas as janelas ativas na área de trabalho atual. Isso permite que as janelas sejam mais facilmente colocadas em primeiro plano em um espaço de trabalho desordenado ou movidas para outro espaço de trabalho.</p>
</li>
<li>
<p>Workspace selector: uma área à direita da visão geral Activities, que exibe miniaturas de todas as áreas de trabalho ativas e permite que as áreas de trabalho sejam selecionadas e as janelas sejam movidas de uma área de trabalho para outra.</p>
</li>
<li>
<p>Bandeja de mensagens: oferece uma maneira de acessar as notificações enviadas por aplicativos ou componentes do sistema ao GNOME. Se uma notificação ocorrer, normalmente, ela será exibida primeiro brevemente como uma única linha na parte superior da tela e um indicador persistente aparecerá no centro da barra superior ao lado do relógio para informar o usuário sobre as notificações que foram recebidas recentemente. Você pode abrir a bandeja de mensagens para analisar essas notificações clicando no relógio na barra superior ou pressionando Super+m. Você pode fechar a bandeja de mensagens clicando no relógio na barra superior ou pressionando Esc ou Super+M novamente.</p>
</li>
</ol>
<p><img src="/3h.png" alt="HTB"></p>
<p>Você pode visualizar e editar os atalhos de teclado do GNOME usados por sua conta. Abra o menu do sistema no lado direito da barra superior. Clique no botão Settings na parte inferior do menu à esquerda. Na janela do aplicativo que é aberta, selecione Devices → Keyborad no painel esquerdo. O painel direito exibirá suas configurações de atalho atuais.</p>
<h2 id="nota">Nota</h2>
<p>Pode ser difícil enviar alguns atalhos de teclado, como as teclas de função ou a tecla Super, para uma máquina virtual. Isso ocorre porque as teclas especiais usadas por esses atalhos podem ser capturadas pelo sistema operacional local ou pelo aplicativo que você está usando para acessar a área de trabalho gráfica de sua máquina virtual.</p>
<h2 id="importante">Importante</h2>
<p>Nos ambientes de treinamento virtual e individualizado atuais da Red Hat, usar a tecla Super pode ser um pouco complicado. Você provavelmente não poderá usar a tecla Super do teclado porque ela, muitas vezes, não é passada para a máquina virtual no ambiente de sala de aula pelo seu navegador da web.</p>
<p>Na parte superior da janela do navegador que exibe a interface da sua máquina virtual, deve haver um ícone de teclado no lado direito. Se você clicar nele, será aberto um teclado na tela. Clicando novamente, o teclado na tela será fechado.</p>
<p>O teclado na tela trata a Super como uma tecla modificadora que é frequentemente pressionada com outra tecla. Se você clicar nela uma vez, ela ficará amarela, indicando que está sendo pressionada. Então, para pressionar Super+M no teclado na tela, clique em Super e em M.</p>
<p>Se você desejar apenas pressionar e soltar Super no teclado na tela, deverá clicar duas vezes nela. O primeiro clique mantém a tecla Super pressionada, e o segundo clique a libera.</p>
<p>As outras teclas tratadas como teclas modificadoras (como a Super) pelo teclado na tela são Shift, Ctrl, Alt e Caps. As teclas Esc e Menu são tratadas como teclas normais e não como teclas modificadoras.</p>
<h2 id="espaços-de-trabalho">Espaços de trabalho</h2>
<p>Os espaços de trabalho são telas separadas que têm janelas de aplicativo diferentes. Eles podem ser usados para organizar seu ambiente de trabalho agrupando janelas de aplicativo abertas por tarefas. Por exemplo, janelas usadas para executar uma determinada atividade de manutenção do sistema (como a configuração de um novo servidor remoto) podem ser agrupadas em um espaço de trabalho, enquanto e-mails e outros aplicativos de comunicação podem ser agrupados em outro espaço de trabalho.</p>
<p>Há dois métodos simples para alternar entre espaços de trabalho. um método, talvez o mais rápido, é pressionar Ctrl+Alt+seta para cima ou Ctrl+Alt+seta para baixo para alternar entre espaços de trabalho em sequência. O segundo é alternar para a visão geral Activities desejada e clicar no espaço de trabalho.</p>
<p>Uma vantagem de usar a visão geral Activities é que as janelas podem ser clicadas e arrastadas entre o espaço de trabalho usando o workspace selector à direita da tela, e a windows overview, no centro da tela.</p>
<h2 id="importante-1">Importante</h2>
<p>Assim como a Super, nos ambientes atuais de treinamento virtual e individualizado da Red Hat, as combinações de teclas Ctrl+Alt não são geralmente passadas para a máquina virtual no ambiente de sala de aula pelo seu navegador da web.</p>
<p>Você pode inserir essas combinações de teclas para alternar espaços de trabalho usando o teclado na tela. Pelo menos dois espaços de trabalho precisam estar em uso. Abra o teclado na tela e clique em Ctrl, Alt e, em seguida, na seta para cima ou na seta para baixo.</p>
<p>No entanto, nesses ambientes de treinamento, geralmente é mais simples evitar os atalhos de teclado e o teclado na tela. Alterne espaços de trabalho clicando no botão Activities e, em seguida, no seletor de área de trabalho à direita da visão geral Activities, clicando no espaço de trabalho para o qual você deseja alternar.</p>
<h2 id="inicialização-de-um-terminal">Inicialização de um terminal</h2>
<p>Para obter um prompt do shell no GNOME, inicie um aplicativo de terminal gráfico, como o GNOME Terminal. Há várias maneiras de fazer isso. Os dois métodos mais usados estão listados abaixo:</p>
<p>Na visão geral Activities, selecione Terminal no dash (na área dos favoritos, encontrando-o com o botão de grade (no agrupamento Utilities) ou usando o campo de pesquisa na parte superior da windows overview).</p>
<p>Pressione a combinação de teclas Alt+F2 para abrir Enter a Command e digite gnome-terminal.</p>
<p>Quando uma janela de terminal for aberta, um prompt do shell será exibido ao usuário que iniciou o programa de terminal gráfico. O prompt do shell e a barra de título da janela de terminal indicam o nome de usuário atual, o nome do host e o diretório de trabalho.</p>
<h2 id="bloqueio-de-tela-ou-logout">Bloqueio de tela ou logout</h2>
<p>É possível bloquear a tela ou fazer o logout totalmente a partir do menu de sistema no lado direito da barra superior.</p>
<p>Para bloquear a tela, no menu do sistema no canto superior direito, clique no botão de bloqueio na parte inferior do menu ou pressione Super+L (que pode ser mais fácil de lembrar como Windows+L). A tela também é bloqueada se a sessão gráfica ficar inativa por alguns minutos.</p>
<p>Uma lock screen curtain (cortina de tela de bloqueio) aparece, mostrando a hora do sistema e o nome do usuário conectado. Para desbloquear a tela, pressione Enter ou espaço para levantar a cortina de bloqueio de tela; em seguida, insira a senha do usuário na tela de bloqueio.</p>
<p>Para fazer o logout e finalizar a sessão de login gráfico atual, selecione o menu do sistema no canto superior direito da barra superior e clique em (User) → Log Out. Uma janela é exibida, oferecendo a opção de Cancel ou confirmar a ação Log out.</p>
<h2 id="desligamento-ou-reinicialização-do-sistema">Desligamento ou reinicialização do sistema</h2>
<p>Para desligar o sistema, no menu do sistema no canto superior direito, clique no botão liga/desliga na parte inferior do menu ou pressione Ctrl+Alt+Del. Na caixa de diálogo exibida, você pode escolher Power Off (Desligar) ou Restart (Reiniciar) a máquina; ou Cancel (Cancelar) a operação. Se você não fizer uma escolha, o sistema será desligado automaticamente após 60 segundos.</p>
<h2 id="sintaxe-básica-de-comandos">Sintaxe básica de comandos</h2>
<p>O GNU Bourne-Again Shell (bash) é um programa que interpreta comandos digitados pelo usuário. Cada string digitada no shell pode ter até três partes: o comando, as opções (que geralmente começam com - ou &ndash;) e os argumentos. Cada palavra digitada no shell é separada por espaços. Comandos são os nomes dos programas que estão instalados no sistema. Cada comando tem suas próprias opções e argumentos.</p>
<p>Quando estiver pronto para executar um comando, pressione a tecla Enter. Digite cada comando em uma linha separada. A saída do comando é exibida antes que o próximo prompt do shell seja exibido.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host<span class="o">]</span>$ whoami
user
<span class="o">[</span>user@host<span class="o">]</span>$ 
</code></pre></div><p>Se quiser digitar mais de um comando em uma única linha, use um ponto e vírgula (;) como separador de comandos. Um ponto e vírgula é um membro de uma classe de caracteres chamada metacaracteres que tem significados especiais para o bash. Nesse caso, a saída de ambos os comandos será exibida antes de o próximo prompt shell aparecer.</p>
<p>O exemplo a seguir mostra como combinar dois comandos (command1 e command2) na linha de comando.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host<span class="o">]</span>$ command1<span class="p">;</span>command2
</code></pre></div><h2 id="exemplos-de-comandos-simples">Exemplos de comandos simples</h2>
<p>O comando date mostra a data e a hora atuais. Ele também pode ser usado pelo superusuário para ajustar o relógio do sistema. Um argumento que começa por um sinal de mais (+) define a string de formatação para o comando date.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ date
Sat Jan  <span class="m">26</span> 08:13:50 IST <span class="m">2019</span>
<span class="o">[</span>user@host ~<span class="o">]</span>$ date +%R
08:13
<span class="o">[</span>user@host ~<span class="o">]</span>$ date +%x
01/26/2019
</code></pre></div><p>O comando passwd altera a senha do próprio usuário. A senha original da conta deverá ser indicada para que uma alteração seja permitida. Por padrão, passwd está configurado para solicitar uma senha segura, composta por letras minúsculas, maiúsculas, números e símbolos e que não seja baseada em uma palavra do dicionário. O superusuário pode usar o comando passwd para alterar as senhas de outros usuários.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ passwd
Changing password <span class="k">for</span> user user.
Current password: old_password
New password: new_password
Retype new password: new_password
passwd: all authentication tokens updated successfully.
</code></pre></div><p>O Linux não exige extensões de nome de arquivo para classificar arquivos por tipo. O comando file varre o início do conteúdo de um arquivo e exibe seu tipo. Os arquivos a serem classificados serão passados como argumentos ao comando.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ file /etc/passwd
/etc/passwd: ASCII text
<span class="o">[</span>user@host ~<span class="o">]</span>$ file /bin/passwd
/bin/passwd: setuid ELF 64-bit LSB shared object, x86-64, version <span class="m">1</span> 
<span class="o">(</span>SYSV<span class="o">)</span>, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, 
<span class="k">for</span> GNU/Linux 3.2.0, BuildID<span class="o">[</span>sha1<span class="o">]=</span>a3637110e27e9a48dced9f38b4ae43388d32d0e4, stripped
<span class="o">[</span>user@host ~<span class="o">]</span>$ file /home
/home: directory
</code></pre></div><h2 id="visualização-do-conteúdo-dos-arquivos">Visualização do conteúdo dos arquivos</h2>
<p>Um dos comandos mais simples e frequentemente usados no Linux é o cat. O comando cat permite criar múltiplos arquivos ou arquivos únicos, visualizar o conteúdo dos arquivos, concatenar o conteúdo de vários arquivos e redirecionar o conteúdo do arquivo a um terminal ou a arquivos.</p>
<p>O exemplo mostra como visualizar o conteúdo do arquivo /etc/passwd.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
...output omitted...
</code></pre></div><p>Use o comando a seguir para exibir o conteúdo de vários arquivos.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ cat file1 file2
Hello World!!
Introduction to Linux commands.
</code></pre></div><p>Alguns arquivos são muito longos e podem ocupar mais espaço para serem exibidos do que o fornecido pelo terminal. O comando cat não exibe o conteúdo de um arquivo como páginas. O comando less exibe uma página de um arquivo de cada vez e permite que você percorra as páginas.</p>
<p>O comando less permite que você avance e volte nas páginas por meio de arquivos mais compridos que cabem em uma janela de terminal. Use as teclas de seta para cima e seta para baixo para rolar para cima e para baixo. Pressione q para sair do comando.</p>
<p>Os comandos head e tail exibem o início e o fim de um arquivo, respectivamente. Por padrão, esses comandos exibem 10 linhas do arquivo, mas ambos têm uma opção -n que permite especificar um número diferente de linhas. O arquivo a ser exibido será passado como um argumento para esses comandos.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ head /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
<span class="o">[</span>user@host ~<span class="o">]</span>$ tail -n <span class="m">3</span> /etc/passwd
gdm:x:42:42::/var/lib/gdm:/sbin/nologin
gnome-initial-setup:x:977:977::/run/gnome-initial-setup/:/sbin/nologin
avahi:x:70:70:Avahi mDNS/DNS-SD Stack:/var/run/avahi-daemon:/sbin/nologin
</code></pre></div><p>O comando wc conta linhas, palavras e caracteres em um arquivo. É preciso de uma opção -l, -w ou -c para exibir apenas linhas, palavras ou caracteres, respectivamente.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ wc /etc/passwd
  <span class="m">45</span>  <span class="m">102</span> <span class="m">2480</span> /etc/passwd
<span class="o">[</span>user@host ~<span class="o">]</span>$ wc -l /etc/passwd <span class="p">;</span> wc -l /etc/group
<span class="m">45</span> /etc/passwd
<span class="m">70</span> /etc/group
<span class="o">[</span>user@host ~<span class="o">]</span>$ wc -c /etc/group /etc/hosts
 <span class="m">966</span> /etc/group
 <span class="m">516</span> /etc/hosts
<span class="m">1482</span> total
</code></pre></div><h2 id="preenchimento-com-tab">Preenchimento com Tab</h2>
<p>O preenchimento com Tab permite que o usuário complete comandos ou nomes de arquivo rapidamente depois de digitar uma parte suficiente no prompt para torná-los exclusivos. Se os caracteres digitados não forem únicos, pressionar a tecla Tab duas vezes mostra todos os comandos iniciados pelos caracteres já digitados.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ pas1Tab+Tab
passwd       paste        pasuspender
<span class="o">[</span>user@host ~<span class="o">]</span>$ pass2Tab
<span class="o">[</span>user@host ~<span class="o">]</span>$ passwd 
Changing password <span class="k">for</span> user user.
Current password: 
</code></pre></div><p>1 Pressione Tab duas vezes.</p>
<p>2 Pressione Tab uma vez.</p>
<p>O preenchimento com Tab pode ser usado para completar os nomes de arquivo ao digitá-los como argumentos de comandos. Quando a tecla Tab é pressionada, ela preenche o nome do arquivo, tanto quanto possível. Pressionar Tab uma segunda vez fará com que o shell liste todos os arquivos que correspondam ao padrão atual. Digite caracteres adicionais até o nome ser exclusivo e use o preenchimento com Tab para completar o comando.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ ls /etc/pas1Tab
<span class="o">[</span>user@host ~<span class="o">]</span>$ ls /etc/passwd2Tab
passwd   passwd-
</code></pre></div><p>1 2 Pressione Tab uma vez.</p>
<p>É possível corresponder argumentos e opções usando o preenchimento com Tab para muitos comandos. O comando useradd é usado pelo superusuário, root, para criar usuários adicionais no sistema. Muitas opções podem ser usadas para controlar como esse comando se comporta. O preenchimento com Tab após uma opção parcial pode ser utilizado para concluir a opção sem precisar digitar muito.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@host ~<span class="o">]</span><span class="c1">## useradd --1Tab+Tab</span>
--base-dir        --groups          --no-log-init     --shell
--comment         --help            --non-unique      --skel
--create-home     --home-dir        --no-user-group   --system
--defaults        --inactive        --password        --uid
--expiredate      --key             --root            --user-group
--gid             --no-create-home  --selinux-user
<span class="o">[</span>root@host ~<span class="o">]</span><span class="c1">## useradd --</span>
</code></pre></div><p>1 Pressione Tab duas vezes.</p>
<h2 id="continuação-de-um-longo-comando-em-outra-linha">Continuação de um longo comando em outra linha</h2>
<p>Comandos com muitas opções e argumentos podem rapidamente se tornar longos e são automaticamente envolvidos pela janela de comando quando o cursor atinge a margem direita. Em vez disso, para facilitar a legibilidade do comando, você pode digitar um comando longo usando mais de uma linha.</p>
<p>Para fazer isso, você usará um caractere de barra invertida (), referido como o caractere escape, para ignorar o significado do caractere imediatamente após a barra invertida. Você aprendeu que inserir um caractere de nova linha, pressionando a tecla Enter, informa ao shell que a entrada do comando está completa e que o comando deve ser executado. Ao usar o escape para o caractere de nova linha, o shell é instruído a mudar para uma nova linha de comando sem o executar. O shell reconhece a solicitação exibindo um prompt de continuação, chamado de prompt secundário, usando o caractere maior do que (&gt;) por padrão em uma nova linha vazia. Os comandos podem ser continuados em muitas linhas.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host<span class="o">]</span>$ head -n <span class="m">3</span> <span class="se">\
</span><span class="se"></span>&gt; /usr/share/dict/words <span class="se">\
</span><span class="se"></span>&gt; /usr/share/dict/linux.words
<span class="o">==</span>&gt; /usr/share/dict/words &lt;<span class="o">==</span>
<span class="m">1080</span>
10-point
<span class="nv">10th</span>

<span class="o">==</span>&gt; /usr/share/dict/linux.words &lt;<span class="o">==</span>
<span class="m">1080</span>
10-point
10th
<span class="o">[</span>user@host ~<span class="o">]</span>$ 
</code></pre></div><h2 id="importante-2">Importante</h2>
<p>O exemplo de tela anterior mostra como um comando continuado aparece para um usuário típico. No entanto, promover esse realismo em materiais didáticos, como este livro, geralmente causa confusão. Os novos alunos podem inserir por engano o caractere maior do que adicional como parte do comando digitado. O shell interpreta um caractere maior do que digitado como redirecionamento de processo, o que não era o objetivo do usuário. O redirecionamento de processos é discutido em um próximo capítulo.</p>
<p>Para evitar essa confusão, este livro não mostrará prompts secundários nas saídas da tela. Um usuário ainda verá o prompt secundário em sua janela do shell, mas o material do curso exibe intencionalmente apenas caracteres para serem digitados, conforme demonstrado no exemplo abaixo. Compare com o exemplo de tela anterior.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host<span class="o">]</span>$ head -n <span class="m">3</span> <span class="se">\
</span><span class="se"></span>/usr/share/dict/words <span class="se">\
</span><span class="se"></span>/usr/share/dict/linux.words
<span class="o">==</span>&gt; /usr/share/dict/words &lt;<span class="o">==</span>
<span class="m">1080</span>
10-point
<span class="nv">10th</span>

<span class="o">==</span>&gt; /usr/share/dict/linux.words &lt;<span class="o">==</span>
<span class="m">1080</span>
10-point
10th
<span class="o">[</span>user@host ~<span class="o">]</span>$ 
</code></pre></div><h2 id="histórico-de-comandos">Histórico de comandos</h2>
<p>O comando history exibe uma lista de comandos executados anteriormente precedidos por um número.</p>
<p>O caractere ponto de exclamação (!) é um metacaractere usado para expandir comandos anteriores sem precisar redigitá-los. O comando !number expande o comando que corresponde ao número indicado. O comando !string expande o comando mais recente que começa com a string especificada.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nb">history</span>
   ...output omitted...
   <span class="m">23</span>  clear
   <span class="m">24</span>  who
   <span class="m">25</span>  <span class="nb">pwd</span>
   <span class="m">26</span>  ls /etc
   <span class="m">27</span>  uptime
   <span class="m">28</span>  ls -l
   <span class="m">29</span>  date
   <span class="m">30</span>  <span class="nb">history</span>
<span class="o">[</span>user@host ~<span class="o">]</span>$ !ls
ls -l
total <span class="m">0</span>
drwxr-xr-x. <span class="m">2</span> user user <span class="m">6</span> Mar <span class="m">29</span> 21:16 Desktop
...output omitted...
<span class="o">[</span>user@host ~<span class="o">]</span>$ !26
ls /etc
abrt                     hosts                     pulse
adjtime                  hosts.allow               purple
aliases                  hosts.deny                qemu-ga
...output omitted...
</code></pre></div><p>As teclas de seta podem ser usadas para navegar pelos comandos anteriores no histórico do shell. A seta para cima edita o comando anterior na lista do histórico. A seta para baixo edita o próximo comando na lista do histórico. A seta para a esquerda e a seta para a direita movem o cursor para a esquerda e para a direita no comando atual da lista de histórico, para que você possa editá-lo antes de executá-lo.</p>
<p>Você pode usar a combinação de teclas Esc+. ou Alt+. para inserir a última palavra do comando anterior na localização atual do cursor. O uso repetido da combinação de teclas substituirá esse texto pela última palavra dos comandos anteriores do histórico. A combinação de teclas Alt+. é particularmente conveniente porque você pode segurar Alt e pressionar . repetidamente para percorrer facilmente pelos comandos anteriores.</p>
<h2 id="edição-da-linha-de-comando">Edição da linha de comando</h2>
<p>Quando usado de forma interativa, bash tem um recurso de edição de linha de comando. Isso permite que o usuário utilize os comandos do editor de texto para se mover e modificar o comando atual sendo digitado. O movimento no comando atual e a passagem pelo histórico de comandos usando as teclas de seta foram introduzidos anteriormente nesta sessão. Comandos de edição mais poderosos são apresentados na tabela a seguir.</p>
<p>Atalho = Descrição</p>
<p>Ctrl+A =&gt; Ir para o início da linha de comando.</p>
<p>Ctrl+E =&gt; Ir para o final da linha de comando.</p>
<p>Ctrl+U =&gt; Limpar do cursor ao início da linha de
comando.</p>
<p>Ctrl+K =&gt; Limpar do cursor até o final da linha de comando.</p>
<p>Ctrl+seta =&gt; para a esquerda 	Ir para o início da palavra anterior na linha de comando.</p>
<p>Ctrl+seta =&gt; para a direita 	Ir para o final da próxima palavra na linha de comando.</p>
<p>Ctrl+R =&gt; Pesquisar um padrão na lista de histórico de comandos.</p>
<p>Há vários outros comandos de edição de linha de comando disponíveis, mas esses são os comandos mais úteis para novos usuários. Os outros comandos podem ser encontrados na página do man bash</p>
<ol>
<li>Use o comando date para exibir a data e a hora atuais</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>student@workstation ~<span class="o">]</span>$ date
Thu Jan <span class="m">22</span> 10:13:04 PDT <span class="m">2019</span>
</code></pre></div><ol start="2">
<li>Mostrar a hora atual no formato de 12 horas (por exemplo, 11:42:11 AM). Dica: a string de formato que exibe a saída é %r.</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>student@workstation ~<span class="o">]</span>$ date +%r
10:14:07 AM
</code></pre></div><ol start="3">
<li>Qual tipo de arquivo é /home/student/zcat? Ele é legível?</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">➜  ~ file /usr/bin/zcat
/usr/bin/zcat: POSIX shell script, ASCII text executable
</code></pre></div><ol start="4">
<li>Use o comando wc e os atalhos do Bash para exibir o tamanho de zcat.</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">➜  ~ wc /usr/bin/zcat 
  <span class="m">51</span>  <span class="m">299</span> <span class="m">1984</span> /usr/bin/zcat
</code></pre></div><ol start="5">
<li>Exiba as 10 primeiras linhas de zcat.</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">➜  ~ head h10 /usr/bin/zcat 
head: não foi possível abrir <span class="s1">&#39;h10&#39;</span> para leitura: Arquivo ou diretório <span class="nv">inexistente</span>
<span class="o">==</span>&gt; /usr/bin/zcat &lt;<span class="o">==</span>
<span class="c1">#!/bin/sh</span>
<span class="c1"># Uncompress files to standard output.</span>

<span class="c1"># Copyright (C) 2007, 2010-2018 Free Software Foundation, Inc.</span>

<span class="c1"># This program is free software; you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation; either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
</code></pre></div><ol start="6">
<li>Exiba as 10 últimas linhas do arquivo zcat.</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">➜  ~ tail -n <span class="m">10</span> /usr/bin/zcat
With no FILE, or when FILE is -, <span class="nb">read</span> standard input.

Report bugs to &lt;bug-gzip@gnu.org&gt;.<span class="s2">&#34;
</span><span class="s2">
</span><span class="s2">case </span><span class="nv">$1</span><span class="s2"> in
</span><span class="s2">--help)    printf &#39;%s\n&#39; &#34;</span><span class="nv">$usage</span><span class="s2">&#34;   || exit 1; exit;;
</span><span class="s2">--version) printf &#39;%s\n&#39; &#34;</span><span class="nv">$version</span><span class="s2">&#34; || exit 1; exit;;
</span><span class="s2">esac
</span><span class="s2">
</span><span class="s2">exec gzip -cd &#34;</span><span class="nv">$@</span><span class="s2">&#34;
</span></code></pre></div><ol start="7">
<li>Repita o comando anterior exato pressionando as teclas três vezes ou menos.</li>
</ol>
<p>Repita o comando anterior exato. Pressione a tecla de seta para cima uma vez para voltar no histórico do comando e pressione Enter (duas vezes), ou digite o comando de atalho !! e, depois, pressione Enter (três vezes) para executar o comando mais recente no histórico de comandos. (Tente usar ambos.)</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>student@workstation<span class="o">]</span>$ !!
tail zcat
With no FILE, or when FILE is -, <span class="nb">read</span> standard input.

Report bugs to &lt;bug-gzip@gnu.org&gt;.<span class="s2">&#34;
</span><span class="s2">
</span><span class="s2">case </span><span class="nv">$1</span><span class="s2"> in
</span><span class="s2">--help)    printf &#39;%s\n&#39; &#34;</span><span class="nv">$usage</span><span class="s2">&#34;   || exit 1;;
</span><span class="s2">--version) printf &#39;%s\n&#39; &#34;</span><span class="nv">$version</span><span class="s2">&#34; || exit 1;;
</span><span class="s2">esac
</span><span class="s2">
</span><span class="s2">exec gzip -cd &#34;</span><span class="nv">$@</span><span class="s2">&#34;
</span></code></pre></div><ol start="8">
<li>Repita o comando anterior, mas use a opção -n 20 para exibir as últimas 20 linhas no arquivo. Use a edição de linha de comando para fazer isso com o mínimo de pressionamento de teclas.</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">➜  ~ tail -n <span class="m">20</span> /usr/bin/zcat
  -l, --list        list compressed file contents
  -q, --quiet       suppress all warnings
  -r, --recursive   operate recursively on directories
  -S, --suffix<span class="o">=</span>SUF  use suffix SUF on compressed files
      --synchronous synchronous output <span class="o">(</span>safer <span class="k">if</span> system crashes, but slower<span class="o">)</span>
  -t, --test        <span class="nb">test</span> compressed file integrity
  -v, --verbose     verbose mode
      --help        display this <span class="nb">help</span> and <span class="nb">exit</span>
      --version     display version information and <span class="nb">exit</span>

With no FILE, or when FILE is -, <span class="nb">read</span> standard input.

Report bugs to &lt;bug-gzip@gnu.org&gt;.<span class="s2">&#34;
</span><span class="s2">
</span><span class="s2">case </span><span class="nv">$1</span><span class="s2"> in
</span><span class="s2">--help)    printf &#39;%s\n&#39; &#34;</span><span class="nv">$usage</span><span class="s2">&#34;   || exit 1; exit;;
</span><span class="s2">--version) printf &#39;%s\n&#39; &#34;</span><span class="nv">$version</span><span class="s2">&#34; || exit 1; exit;;
</span><span class="s2">esac
</span><span class="s2">
</span><span class="s2">exec gzip -cd &#34;</span><span class="nv">$@</span><span class="s2">&#34;
</span></code></pre></div><ol start="9">
<li>Use o histórico do shell para executar o comando date +%r novamente.</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>student@workstation ~<span class="o">]</span>$ <span class="nb">history</span>
<span class="m">1</span>   date
<span class="m">2</span>   date +%r
<span class="m">3</span>   file zcat
<span class="m">4</span>   wc zcat
<span class="m">5</span>   head zcat
<span class="m">6</span>   tail zcat
<span class="m">7</span>   tail -n <span class="m">20</span> zcat
<span class="m">8</span>   <span class="nb">history</span>
<span class="o">[</span>student@workstation ~<span class="o">]</span>$ !2
date +%r
10:49:56 AM
</code></pre></div><p>=&gt; O shell Bash é um interpretador de comandos que solicita aos usuários interativos que especifiquem os comandos do Linux.</p>
<p>=&gt; Muitos comandos têm uma opção &ndash;help que exibe uma tela ou mensagem de uso.</p>
<p>=&gt; A utilização de espaços de trabalho facilita a organização de várias janelas de aplicativos.</p>
<p>=&gt; O botão Activities no canto superior esquerdo da barra superior fornece um modo de visão geral que ajuda o usuário a organizar janelas e iniciar aplicativos.</p>
<p>=&gt; O comando file varre o início do conteúdo de um arquivo e exibe seu tipo.</p>
<p>=&gt; Os comandos head e tail exibem o início e o fim de um arquivo, respectivamente.</p>
<p>=&gt; Você pode usar o preenchimento Tab para preencher nomes de arquivos ao digitá-los como argumentos para os comandos.</p>
<p><a href="https://rha.ole.redhat.com/rha/app/courses/rh124-8.2/pages/ch03">https://rha.ole.redhat.com/rha/app/courses/rh124-8.2/pages/ch03</a></p>
<h2 id="capítulo-3-gerenciamento-de-arquivos-na-linha-de-comando">Capítulo 3. Gerenciamento de arquivos na linha de comando</h2>
<p>A hierarquia do sistema de arquivos</p>
<p>Todos os arquivos em um sistema Linux são armazenados em sistemas de arquivos, que são organizados em uma única árvore de diretório invertida, conhecida como hierarquia do sistema de arquivos. Essa árvore é invertida porque dizemos que a raiz dela está na parte superior da hierarquia e os ramos de diretórios e subdiretórios se estendem abaixo da raiz (root).</p>
<p><img src="/4h.png" alt="HTB"></p>
<p>O diretório / é o diretório root no topo da hierarquia do sistema de arquivos. O caractere / também é usado como separador de diretórios nos nomes de arquivos. Por exemplo, se etc for um subdiretório do diretório /, é possível chamá-lo de /etc. Do mesmo modo, se o diretório /etc contiver um arquivo chamado issue, é possível referir-se ao arquivo como /etc/issue.</p>
<p>Os subdiretórios de / são usados com fins padronizados para organizar arquivos por tipo e finalidade. Assim, fica mais fácil encontrar arquivos. Por exemplo, no diretório root, o subdiretório /boot é utilizado para armazenar os arquivos necessários para o boot do sistema.</p>
<h2 id="nota-1">Nota</h2>
<p>Os seguintes termos ajudam a descrever o conteúdo do diretório do sistema de arquivos:</p>
<p>=&gt; O conteúdo estático permanece inalterado até que seja editado ou reconfigurado.</p>
<p>=&gt; O conteúdo dinâmico ou variável pode ser modificado ou inserido pelos processos ativos.</p>
<p>=&gt; O conteúdo persistente permanece após uma reinicialização, como definições de configuração.</p>
<p>=&gt; O conteúdo de tempo de execução é específico de processos ou sistemas e é excluído por uma reinicialização.</p>
<h2 id="diretórios-importantes-do-red-hat-enterprise-linux">Diretórios importantes do Red Hat Enterprise Linux</h2>
<p>/usr</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">Software instalado, bibliotecas compartilhadas, arquivos incluídos e dados de programas somente leitura. Subdiretórios importantes incluem:

/usr/bin: comandos de usuário.

/usr/sbin: comandos de administração <span class="k">do</span> sistema.

/usr/local: software personalizado localmente. 
</code></pre></div><p>/etc</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">Arquivos de configuração específicos deste sistema. 
</code></pre></div><p>/var</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">Dados variáveis específicos deste sistema que devem persistir entre boots <span class="k">do</span> sistema. Os arquivos que mudam de modo dinâmico<span class="p">;</span> por exemplo, bancos de dados, diretórios de cache, arquivos de log, documentos com spool de impressora e conteúdo de sites podem ser encontrados em /var.  
</code></pre></div><p>/run</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"> Dados de tempo de execução de processos iniciados desde o último boot. Isso inclui arquivos de ID de processos e arquivos de bloqueio, entre outros. O conteúdo desse diretório é recriado na reinicialização. Este diretório consolida /var/run e /var/lock de versões anteriores <span class="k">do</span> Red Hat Enterprise Linux. 
</code></pre></div><p>/home</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">Diretórios pessoais são os locais onde os usuários normais armazenam seus dados pessoais e arquivos de configuração. 
</code></pre></div><p>/root</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">Diretório pessoal <span class="k">do</span> superusuário administrativo, root. 
</code></pre></div><p>/tmp</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">Um espaço gravável para arquivos temporários. Arquivos não acessados, alterados nem modificados por <span class="m">10</span> dias são excluídos automaticamente desse diretório. Há outro diretório temporário, /var/tmp, no qual os arquivos que não tiverem sido acessados, alterados ou modificados por mais de <span class="m">30</span> dias serão excluídos automaticamente. 
</code></pre></div><p>/boot</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">Arquivos necessários para começar o processo de boot. 
</code></pre></div><p>/dev</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">Contém arquivos de dispositivos especiais que são usados pelo sistema para acessar o hardware. 
</code></pre></div><h2 id="importante-3">Importante</h2>
<p>No Red Hat Enterprise Linux 7 e posteriores, quatro diretórios mais antigos em / têm o mesmo conteúdo de suas contrapartes localizadas em /usr:</p>
<p>/bin e /usr/bin</p>
<p>/sbin e /usr/sbin</p>
<p>/lib e /usr/lib</p>
<p>/lib64 e /usr/lib64</p>
<p>Em versões anteriores do Red Hat Enterprise Linux, esses diretórios eram diferentes e continham conjuntos distintos de arquivos.</p>
<p>No Red Hat Enterprise Linux 7 e posteriores, os diretórios em / são links simbólicos para as pastas correspondentes em /usr.</p>
<h2 id="especificação-de-arquivos-por-nome">Especificação de arquivos por nome</h2>
<p><img src="/5h.png" alt="HTB"></p>
<p>A visualização do navegador de arquivos comum (à esquerda) é equivalente à visualização descendente (à direita).</p>
<p>O caminho de um arquivo ou diretório especifica o local exclusivo no sistema de arquivos. Seguir o caminho de um arquivo atravessa um ou mais subdiretórios nomeados, delimitados por uma barra (/), até chegar ao destino. Os diretórios, também chamados de pastas, contêm outros arquivos e outros subdiretórios. Eles podem ser referenciados da mesma maneira que os arquivos.</p>
<h2 id="importante-4">Importante</h2>
<p>Um caractere de espaço é aceitável como parte de um nome de arquivo do Linux. No entanto, espaços também são usados pelo shell para separar opções e argumentos na linha de comando. Se você inserir um comando que inclua um arquivo que tenha um espaço no nome, o shell poderá interpretar erroneamente o comando e entender que você deseja iniciar um novo nome de arquivo ou outro argumento no espaço.</p>
<p>É possível evitar isso colocando nomes de arquivos entre aspas. No entanto, se você não precisar usar espaços em nomes de arquivos, pode ser mais simples simplesmente evitá-los.</p>
<p>=&gt; Caminhos absolutos</p>
<p>Um caminho absoluto é um nome totalmente qualificado, especificando a localização exata dos arquivos na hierarquia do sistema de arquivos. Ele começa no diretório raiz (/) e especifica cada subdiretório que deve ser percorrido para alcançar o arquivo específico. Cada arquivo em um sistema de arquivos tem um nome de caminho absoluto exclusivo, reconhecido por uma regra simples: um nome de arquivo com uma barra (/) como primeiro caractere é um nome de caminho absoluto. Por exemplo, o nome de caminho absoluto do arquivo de log do sistema de mensagens é /var/log/messages. Nomes de caminhos absolutos podem ser longos, por isso, os arquivos também podem ser localizados em relação ao diretório de trabalho atual para o prompt do shell.</p>
<p>=&gt; O diretório de trabalho atual e caminhos relativos</p>
<p>Quando um usuário fizer login e abrir uma janela de comando, normalmente a localização inicial será o diretório pessoal do usuário. Os processos do sistema também têm um diretório inicial. Usuários e processos navegam a outros diretórios, conforme necessário; os termos diretório de trabalho ou diretório de trabalho atual são referentes ao local atual.</p>
<p>Assim como um caminho absoluto, um caminho relativo identifica um único arquivo, especificando somente o caminho necessário para acessar o arquivo no diretório de trabalho local. O reconhecimento de nomes de caminho relativos segue uma regra simples: um nome de caminho com qualquer caractere diferente de uma barra como primeiro caractere é um nome de caminho relativo. Um usuário no diretório /var pode fazer referência ao arquivo de log de mensagens de modo relativo como log/messages.</p>
<p>Sistemas de arquivos Linux, incluindo, entre outros, ext4, XFS, GFS2 e GlusterFS, diferenciam maiúsculas de minúsculas. A criação de FileCase.txt e filecase.txt no mesmo diretório resulta em dois arquivos exclusivos.</p>
<p>Sistemas de arquivos que não são do Linux podem funcionar de modo diferente. Por exemplo, o VFAT, o NTFS da Microsoft e o HFS+ da Apple, têm um comportamento de preservação de maiúsculas e minúsculas. Embora esses sistemas de arquivos não diferenciem maiúsculas de minúsculas, eles exibem os nomes de arquivo com as letras originais usada durante a criação do arquivo. Portanto, se você tentou criar os arquivos no exemplo anterior em um sistema de arquivos VFAT, ambos os nomes seriam tratados como apontando para o mesmo arquivo em vez de dois arquivos diferentes.</p>
<p>Caminhos de navegação</p>
<p>O comando pwd exibe o nome do caminho completo do diretório de trabalho atual para esse shell. Isso pode ajudar você a determinar a sintaxe para acessar arquivos usando nomes de caminho relativos. O comando ls lista o conteúdo do diretório especificado ou, caso um diretório não seja fornecido, do diretório de trabalho atual.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nb">pwd</span>
/home/user
<span class="o">[</span>user@host ~<span class="o">]</span>$ ls
Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos
<span class="o">[</span>user@host ~<span class="o">]</span>$
</code></pre></div><p>Use o comando cd para alterar o diretório de trabalho atual do shell. Se você não especificar nenhum argumento para o comando, ele será alterado para o diretório pessoal.</p>
<p>No exemplo a seguir, uma mistura de caminhos absolutos e relativos é usada com o comando cd para alterar o diretório de trabalho atual para o shell.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nb">pwd</span>
/home/user
<span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nb">cd</span> Videos
<span class="o">[</span>user@host Videos<span class="o">]</span>$ <span class="nb">pwd</span>
/home/user/Videos
<span class="o">[</span>user@host Videos<span class="o">]</span>$ <span class="nb">cd</span> /home/user/Documents
<span class="o">[</span>user@host Documents<span class="o">]</span>$ <span class="nb">pwd</span>
/home/user/Documents
<span class="o">[</span>user@host Documents<span class="o">]</span>$ <span class="nb">cd</span>
<span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nb">pwd</span>
/home/user
<span class="o">[</span>user@host ~<span class="o">]</span>$
</code></pre></div><p>Como você pode ver no exemplo anterior, o prompt de shell padrão também exibe o último componente do caminho absoluto para o diretório de trabalho atual.</p>
<p>Por exemplo, para /home/user/Videos, somente Videos é exibido. O prompt exibe o caractere til &lsquo;~&rsquo; quando o diretório de trabalho atual é o diretório pessoa.</p>
<p>O comando touch normalmente atualiza o carimbo de data e hora de um arquivo para a data e a hora atuais, sem modificá-lo. Isso é útil para a criação de arquivos vazios, que podem ser usados para prática, pois o uso desse comando em um nome de arquivo que não existe faz com que o arquivo seja criado. No exemplo a seguir, o comando touch cria arquivos de prática nos subdiretórios Documents e Videos.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ touch Videos/blockbuster1.ogg
<span class="o">[</span>user@host ~<span class="o">]</span>$ touch Videos/blockbuster2.ogg
<span class="o">[</span>user@host ~<span class="o">]</span>$ touch Documents/thesis_chapter1.odf
<span class="o">[</span>user@host ~<span class="o">]</span>$ touch Documents/thesis_chapter2.odf
<span class="o">[</span>user@host ~<span class="o">]</span>$
</code></pre></div><p>O comando ls tem várias opções para a exibição de atributos nos arquivos. As mais comuns e úteis são -l (formato de listagem longa), -a (todos os arquivos, incluindo os ocultos) e -R (recursão, para incluir o conteúdo de todos os subdiretórios).</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ ls -l
total <span class="m">15</span>
drwxr-xr-x.  <span class="m">2</span> user user <span class="m">4096</span> Feb  <span class="m">7</span> 14:02 Desktop
drwxr-xr-x.  <span class="m">2</span> user user <span class="m">4096</span> Jan  <span class="m">9</span> 15:00 Documents
drwxr-xr-x.  <span class="m">3</span> user user <span class="m">4096</span> Jan  <span class="m">9</span> 15:00 Downloads
drwxr-xr-x.  <span class="m">2</span> user user <span class="m">4096</span> Jan  <span class="m">9</span> 15:00 Music
drwxr-xr-x.  <span class="m">2</span> user user <span class="m">4096</span> Jan  <span class="m">9</span> 15:00 Pictures
drwxr-xr-x.  <span class="m">2</span> user user <span class="m">4096</span> Jan  <span class="m">9</span> 15:00 Public
drwxr-xr-x.  <span class="m">2</span> user user <span class="m">4096</span> Jan  <span class="m">9</span> 15:00 Templates
drwxr-xr-x.  <span class="m">2</span> user user <span class="m">4096</span> Jan  <span class="m">9</span> 15:00 Videos
<span class="o">[</span>user@host ~<span class="o">]</span>$ ls -la
total <span class="m">15</span>
drwx------. <span class="m">16</span> user user   <span class="m">4096</span> Feb  <span class="m">8</span> 16:15 .
drwxr-xr-x.  <span class="m">6</span> root root   <span class="m">4096</span> Feb  <span class="m">8</span> 16:13 ..
-rw-------.  <span class="m">1</span> user user  <span class="m">22664</span> Feb  <span class="m">8</span> 00:37 .bash_history
-rw-r--r--.  <span class="m">1</span> user user     <span class="m">18</span> Jul  <span class="m">9</span>  <span class="m">2013</span> .bash_logout
-rw-r--r--.  <span class="m">1</span> user user    <span class="m">176</span> Jul  <span class="m">9</span>  <span class="m">2013</span> .bash_profile
-rw-r--r--.  <span class="m">1</span> user user    <span class="m">124</span> Jul  <span class="m">9</span>  <span class="m">2013</span> .bashrc
drwxr-xr-x.  <span class="m">4</span> user user   <span class="m">4096</span> Jan <span class="m">20</span> 14:02 .cache
drwxr-xr-x.  <span class="m">8</span> user user   <span class="m">4096</span> Feb  <span class="m">5</span> 11:45 .config
drwxr-xr-x.  <span class="m">2</span> user user   <span class="m">4096</span> Feb  <span class="m">7</span> 14:02 Desktop
drwxr-xr-x.  <span class="m">2</span> user user   <span class="m">4096</span> Jan  <span class="m">9</span> 15:00 Documents
drwxr-xr-x.  <span class="m">3</span> user user   <span class="m">4096</span> Jan <span class="m">25</span> 20:48 Downloads
drwxr-xr-x. <span class="m">11</span> user user   <span class="m">4096</span> Feb  <span class="m">6</span> 13:07 .gnome2
drwx------.  <span class="m">2</span> user user   <span class="m">4096</span> Jan <span class="m">20</span> 14:02 .gnome2_private
-rw-------.  <span class="m">1</span> user user  <span class="m">15190</span> Feb  <span class="m">8</span> 09:49 .ICEauthority
drwxr-xr-x.  <span class="m">3</span> user user   <span class="m">4096</span> Jan  <span class="m">9</span> 15:00 .local
drwxr-xr-x.  <span class="m">2</span> user user   <span class="m">4096</span> Jan  <span class="m">9</span> 15:00 Music
drwxr-xr-x.  <span class="m">2</span> user user   <span class="m">4096</span> Jan  <span class="m">9</span> 15:00 Pictures
drwxr-xr-x.  <span class="m">2</span> user user   <span class="m">4096</span> Jan  <span class="m">9</span> 15:00 Public
drwxr-xr-x.  <span class="m">2</span> user user   <span class="m">4096</span> Jan  <span class="m">9</span> 15:00 Templates
drwxr-xr-x.  <span class="m">2</span> user user   <span class="m">4096</span> Jan  <span class="m">9</span> 15:00 Videos
<span class="o">[</span>user@host ~<span class="o">]</span>$
</code></pre></div><p>Os dois diretórios especiais no topo da lista se referem ao diretório atual (.) e ao diretório pai (..). Esses diretórios especiais existem em todos os diretórios do sistema. Você descobrirá a utilidade deles quando começar a usar comandos de gerenciamento de arquivos.</p>
<h2 id="importante-5">Importante</h2>
<p>Nomes de arquivos começando com um ponto (.) indicam arquivos ocultos; não é possível visualizá-los na exibição normal usando ls e outros comando. Esse não é um recurso de segurança. Os arquivos ocultos impedem que os arquivos de configuração do usuário necessários sobrecarreguem diretórios pessoais. Muitos comandos processam arquivos ocultos apenas com opções de linha de comando especificas, evitando que a configuração de um usuário seja acidentalmente copiada para outros diretórios ou usuários.</p>
<p>Proteger o conteúdo dos arquivos de visualizações inadequadas exige o uso de permissões de arquivo.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ ls -R
.:
Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos

./Desktop:

./Documents:
thesis_chapter1.odf  thesis_chapter2.odf

./Downloads:

./Music:

./Pictures:

./Public:

./Templates:

./Videos:
blockbuster1.ogg  blockbuster2.ogg
<span class="o">[</span>user@host ~<span class="o">]</span>$
</code></pre></div><p>O comando cd tem várias opções. Algumas são tão úteis que é importante praticá-las o mais cedo possível e usá-las com frequência. O comando cd - passa para o diretório anterior, no qual o usuário estava antes do diretório atual. O exemplo a seguir ilustra esse comportamento, alternando entre dois diretórios, o que é útil ao processar uma série de tarefas semelhantes.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nb">cd</span> Videos
<span class="o">[</span>user@host Videos<span class="o">]</span>$ <span class="nb">pwd</span>
/home/user/Videos
<span class="o">[</span>user@host Videos<span class="o">]</span>$ <span class="nb">cd</span> /home/user/Documents
<span class="o">[</span>user@host Documents<span class="o">]</span>$ <span class="nb">pwd</span>
/home/user/Documents
<span class="o">[</span>user@host Documents<span class="o">]</span>$ <span class="nb">cd</span> -
<span class="o">[</span>user@host Videos<span class="o">]</span>$ <span class="nb">pwd</span>
/home/user/Videos
<span class="o">[</span>user@host Videos<span class="o">]</span>$ <span class="nb">cd</span> -
<span class="o">[</span>user@host Documents<span class="o">]</span>$ <span class="nb">pwd</span>
/home/user/Documents
<span class="o">[</span>user@host Documents<span class="o">]</span>$ <span class="nb">cd</span> -
<span class="o">[</span>user@host Videos<span class="o">]</span>$ <span class="nb">pwd</span>
/home/user/Videos
<span class="o">[</span>user@host Videos<span class="o">]</span>$ <span class="nb">cd</span>
<span class="o">[</span>user@host ~<span class="o">]</span>$
</code></pre></div><p>O comando cd .. usa o diretório oculto .. para subir um nível até o diretório pai sem precisar saber o nome exato desse diretório. O outro diretório oculto (.) especifica o diretório atual nos comandos em que a localização atual é o argumento de origem ou de destino, evitando a necessidade de digitar o nome de caminho absoluto do diretório.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host Videos<span class="o">]</span>$ <span class="nb">pwd</span>
/home/user/Videos
<span class="o">[</span>user@host Videos<span class="o">]</span>$ <span class="nb">cd</span> .
<span class="o">[</span>user@host Videos<span class="o">]</span>$ <span class="nb">pwd</span>
/home/user/Videos
<span class="o">[</span>user@host Videos<span class="o">]</span>$ <span class="nb">cd</span> ..
<span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nb">pwd</span>
/home/user
<span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nb">cd</span> ..
<span class="o">[</span>user@host home<span class="o">]</span>$ <span class="nb">pwd</span>
/home
<span class="o">[</span>user@host home<span class="o">]</span>$ <span class="nb">cd</span> ..
<span class="o">[</span>user@host /<span class="o">]</span>$ <span class="nb">pwd</span>
/
<span class="o">[</span>user@host /<span class="o">]</span>$ <span class="nb">cd</span>
<span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nb">pwd</span>
/home/user
<span class="o">[</span>user@host ~<span class="o">]</span>$
</code></pre></div><h2 id="gerenciamento-de-arquivos-usando-ferramentas-de-linha-de-comando">Gerenciamento de arquivos usando ferramentas de linha de comando</h2>
<p>Para gerenciar arquivos, você precisa ser capaz de criar, remover, copiar e mover os arquivos. Você também precisa organizá-los logicamente em diretórios, os quais você também precisa ser capaz de criar, remover, copiar e mover.</p>
<p>A tabela a seguir resume alguns dos comandos mais comuns de gerenciamento de arquivos. O restante desta seção discutirá maneiras de usar esses comandos em mais detalhes.</p>
<p>Atividade =&gt; Sintaxe do comando
Criar um novo diretório =&gt; 	mkdir directory
Copiar um arquivo =&gt; cp file new-file
Copiar um diretório e seu conteúdo  =&gt; cp -r directory new-directory
Mover ou renomear um arquivo ou diretório =&gt; mv file new-file
Remover um arquivo 	=&gt; rm file
Remover um diretório contendo arquivos 	=&gt; rm -r directory
Remover um diretório vazio =&gt; rmdir directory</p>
<h2 id="criação-de-diretórios">Criação de diretórios</h2>
<p>O comando mkdir cria um ou mais diretórios ou subdiretórios. Ele considera como argumentos uma lista de caminhos para os diretórios que você deseja criar.</p>
<p>O comando mkdir falhará com um erro se o diretório já existir ou se você estiver tentando criar um subdiretório em um diretório que não existe. A opção -p (pai) cria diretórios pais ausentes para o destino solicitado. Tenha cautela ao usar o comando mkdir -p pois erros de digitação acidentais podem criar diretórios não pretendidos sem gerar mensagens de erro.</p>
<p>No exemplo a seguir, digamos que você está tentando criar um diretório no Videosdiretório nomeadoWatched, mas acidentalmente deixou a letra &ldquo;s&rdquo; em Videos no comando mkdir.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ mkdir Video/Watched
mkdir: cannot create directory <span class="sb">`</span>Video/Watched<span class="err">&#39;</span>: No such file or directory
</code></pre></div><p>O comando mkdir falhou porque Videos foi digitado incorretamente e o diretório Video não existe. Se você tivesse usado o comando mkdir com a opção -p, o diretório Video seria criado, o que não era o pretendido, e o subdiretório Watched seria criado nesse diretório incorreto.</p>
<p>Depois de escrever corretamente o diretório pai Videos, a criação do subdiretório Watched será bem-sucedida.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ mkdir Videos/Watched
<span class="o">[</span>user@host ~<span class="o">]</span>$ ls -R Videos
Videos/:
blockbuster1.ogg  blockbuster2.ogg  Watched

Videos/Watched:
</code></pre></div><p>No exemplo a seguir, os arquivos e diretórios são organizados abaixo do diretório /home/user/Documents. Use o comando mkdir e uma lista de nomes de diretórios separada por espaços para criar vários diretórios.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nb">cd</span> Documents
<span class="o">[</span>user@host Documents<span class="o">]</span>$ mkdir ProjectX ProjectY
<span class="o">[</span>user@host Documents<span class="o">]</span>$ ls
ProjectX  ProjectY
</code></pre></div><p>Use o comando mkdir -p e caminhos relativos separados por espaços para cada um dos nomes de subdiretórios para criar vários diretórios pai com subdiretórios.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host Documents<span class="o">]</span>$ mkdir -p Thesis/Chapter1 Thesis/Chapter2 Thesis/Chapter3
<span class="o">[</span>user@host Documents<span class="o">]</span>$ <span class="nb">cd</span>
<span class="o">[</span>user@host ~<span class="o">]</span>$ ls -R Videos Documents
Documents:
ProjectX  ProjectY  Thesis

Documents/ProjectX:

Documents/ProjectY:

Documents/Thesis:
Chapter1  Chapter2  Chapter3

Documents/Thesis/Chapter1:

Documents/Thesis/Chapter2:

Documents/Thesis/Chapter3:

Videos:
blockbuster1.ogg  blockbuster2.ogg  Watched

Videos/Watched:
</code></pre></div><p>O último comando mkdir criou subdiretórios de três subdiretórios ChapterN com um comando. A opção -p criou o diretório pai Thesis ausente.</p>
<h2 id="cópia-de-arquivos">Cópia de arquivos</h2>
<p>O comando cp copia um arquivo, criando um novo arquivo no diretório atual ou em um diretório especificado. Ele também pode copiar vários arquivos para um diretório.</p>
<h2 id="atenção">Atenção</h2>
<p>Se o arquivo de destino já existir, o comando cp substitui o arquivo.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nb">cd</span> Videos
<span class="o">[</span>user@host Videos<span class="o">]</span>$ cp blockbuster1.ogg blockbuster3.ogg
<span class="o">[</span>user@host Videos<span class="o">]</span>$ ls -l
total <span class="m">0</span>
-rw-rw-r--. <span class="m">1</span> user user    <span class="m">0</span> Feb  <span class="m">8</span> 16:23 blockbuster1.ogg
-rw-rw-r--. <span class="m">1</span> user user    <span class="m">0</span> Feb  <span class="m">8</span> 16:24 blockbuster2.ogg
-rw-rw-r--. <span class="m">1</span> user user    <span class="m">0</span> Feb  <span class="m">8</span> 16:34 blockbuster3.ogg
drwxrwxr-x. <span class="m">2</span> user user <span class="m">4096</span> Feb  <span class="m">8</span> 16:05 Watched
<span class="o">[</span>user@host Videos<span class="o">]</span>
</code></pre></div><p>Ao copiar vários arquivos com um comando, o último argumento deverá ser um diretório. Os arquivos copiados mantêm seus nomes originais no novo diretório. Se um arquivo com o mesmo nome existir no diretório de destino, o arquivo existente será substituído. Por padrão, o cp não copia diretórios, mas os ignora.</p>
<p>No exemplo a seguir, dois diretórios são listados, Thesis e ProjectX. Apenas o último argumento, ProjectX, é válido como destino. O diretório Thesis é ignorado.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host Videos<span class="o">]</span>$ <span class="nb">cd</span> ../Documents
<span class="o">[</span>user@host Documents<span class="o">]</span>$ cp thesis_chapter1.odf thesis_chapter2.odf Thesis ProjectX
cp: omitting directory <span class="sb">`</span>Thesis<span class="err">&#39;</span>
<span class="o">[</span>user@host Documents<span class="o">]</span>$ ls Thesis ProjectX
ProjectX:
thesis_chapter1.odf  thesis_chapter2.odf

Thesis:
Chapter1  Chapter2  Chapter3
</code></pre></div><p>No primeiro comando cp, a cópia do diretório Thesis falhou, mas os arquivos thesis_chapter1.odf e thesis_chapter2.odf foram copiados com êxito.</p>
<p>Se você desejar copiar um arquivo para o diretório de trabalho atual, poderá usar o diretório .:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ cp /etc/hostname .
<span class="o">[</span>user@host ~<span class="o">]</span>$ cat hostname
host.example.com
<span class="o">[</span>user@host ~<span class="o">]</span>$ 
</code></pre></div><p>Use o comando copy com a opção -r (recursiva) para copiar o diretório Thesis e seu conteúdo para o diretório ProjectX.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host Documents<span class="o">]</span>$ cp -r Thesis ProjectX
<span class="o">[</span>user@host Documents<span class="o">]</span>$ ls -R ProjectX
ProjectX:
Thesis  thesis_chapter1.odf  thesis_chapter2.odf

ProjectX/Thesis:
Chapter1  Chapter2  Chapter3

ProjectX/Thesis/Chapter1:

ProjectX/Thesis/Chapter2:
thesis_chapter2.odf

ProjectX/Thesis/Chapter3:
</code></pre></div><h2 id="movimentação-de-arquivos">Movimentação de arquivos</h2>
<p>O comando mv move arquivos de um local para outro. Se você pensar no caminho absoluto para um arquivo como seu nome completo, mover um arquivo será efetivamente o mesmo que renomear um arquivo. O conteúdo do arquivo permanecerá inalterado.</p>
<p>Use o comando mv para renomear um arquivo.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host Videos<span class="o">]</span>$ <span class="nb">cd</span> ../Documents
<span class="o">[</span>user@host Documents<span class="o">]</span>$ ls -l thesis*
-rw-rw-r--. <span class="m">1</span> user user <span class="m">0</span> Feb  <span class="m">6</span> 21:16 thesis_chapter1.odf
-rw-rw-r--. <span class="m">1</span> user user <span class="m">0</span> Feb  <span class="m">6</span> 21:16 thesis_chapter2.odf
<span class="o">[</span>user@host Documents<span class="o">]</span>$ mv thesis_chapter2.odf thesis_chapter2_reviewed.odf
<span class="o">[</span>user@host Documents<span class="o">]</span>$ ls -l thesis*
-rw-rw-r--. <span class="m">1</span> user user <span class="m">0</span> Feb  <span class="m">6</span> 21:16 thesis_chapter1.odf
-rw-rw-r--. <span class="m">1</span> user user <span class="m">0</span> Feb  <span class="m">6</span> 21:16 thesis_chapter2_reviewed.odf
</code></pre></div><p>Use o comando mv para mover um arquivo para outro diretório.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host Documents<span class="o">]</span>$ ls Thesis/Chapter1
<span class="o">[</span>user@host Documents<span class="o">]</span>$
<span class="o">[</span>user@host Documents<span class="o">]</span>$ mv thesis_chapter1.odf Thesis/Chapter1
<span class="o">[</span>user@host Documents<span class="o">]</span>$ ls Thesis/Chapter1
thesis_chapter1.odf
<span class="o">[</span>user@host Documents<span class="o">]</span>$ ls -l thesis*
-rw-rw-r--. <span class="m">1</span> user user <span class="m">0</span> Feb  <span class="m">6</span> 21:16 thesis_chapter2_reviewed.odf
</code></pre></div><h2 id="remoção-de-arquivos-e-diretórios">Remoção de arquivos e diretórios</h2>
<p>O comando rm remove arquivos. Por padrão, rm não removerá diretórios que contenham arquivos, a menos que você adicione as opções -r ou &ndash;recursive.</p>
<h2 id="importante-6">Importante</h2>
<p>Não existe um recurso de cancelamento de exclusão na linha de comando ou uma Lixeira da qual restaurar arquivos programados para exclusão.</p>
<p>É uma boa ideia verificar seu diretório de trabalho atual antes de remover um arquivo ou diretório.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host Documents<span class="o">]</span>$ <span class="nb">pwd</span>
/home/student/Documents
</code></pre></div><p>Use o comando rm para remover um único arquivo do seu diretório de trabalho.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host Documents<span class="o">]</span>$ ls -l thesis*
-rw-rw-r--. <span class="m">1</span> user user <span class="m">0</span> Feb  <span class="m">6</span> 21:16 thesis_chapter2_reviewed.odf
<span class="o">[</span>user@host Documents<span class="o">]</span>$ rm thesis_chapter2_reviewed.odf
<span class="o">[</span>user@host Documents<span class="o">]</span>$ ls -l thesis*
ls: cannot access <span class="s1">&#39;thesis*&#39;</span>: No such file or directory
</code></pre></div><p>Se você tentar usar o comando rm para remover um diretório sem usar a opção -r, o comando falhará.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host Documents<span class="o">]</span>$ rm Thesis/Chapter1
rm: cannot remove <span class="sb">`</span>Thesis/Chapter1<span class="err">&#39;</span>: Is a directory
</code></pre></div><p>Use o comando rm -r para remover um subdiretório e seu conteúdo.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host Documents<span class="o">]</span>$ ls -R Thesis
Thesis/:
Chapter1  Chapter2  Chapter3

Thesis/Chapter1:
thesis_chapter1.odf

Thesis/Chapter2:
thesis_chapter2.odf

Thesis/Chapter3:
<span class="o">[</span>user@host Documents<span class="o">]</span>$ rm -r Thesis/Chapter1
<span class="o">[</span>user@host Documents<span class="o">]</span>$ ls -l Thesis
total <span class="m">8</span>
drwxrwxr-x. <span class="m">2</span> user user <span class="m">4096</span> Feb <span class="m">11</span> 12:47 Chapter2
drwxrwxr-x. <span class="m">2</span> user user <span class="m">4096</span> Feb <span class="m">11</span> 12:48 Chapter3
</code></pre></div><p>O comando rm -r percorre cada subdiretório primeiro, removendo individualmente seus arquivos antes de remover cada diretório. Você pode usar o comando rm -ri para solicitar interativamente a confirmação antes da exclusão. Isso é essencialmente o oposto de usar a opção -f, que força a remoção sem solicitar a confirmação do usuário.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host Documents<span class="o">]</span>$ rm -ri Thesis
rm: descend into directory <span class="sb">`</span>Thesis<span class="s1">&#39;? y
</span><span class="s1">rm: descend into directory `Thesis/Chapter2&#39;</span>? y
rm: remove regular empty file <span class="sb">`</span>Thesis/Chapter2/thesis_chapter2.odf<span class="s1">&#39;? y
</span><span class="s1">rm: remove directory `Thesis/Chapter2&#39;</span>? y
rm: remove directory <span class="sb">`</span>Thesis/Chapter3<span class="s1">&#39;? y
</span><span class="s1">rm: remove directory `Thesis&#39;</span>? y
<span class="o">[</span>user@host Documents<span class="o">]</span>$
</code></pre></div><h2 id="atenção-1">Atenção</h2>
<p>Se você especificar as opções -i e -f, a opção -f tem prioridade e você não será solicitado para confirmação antes que rm exclua arquivos.</p>
<p>No exemplo a seguir, o comando rmdir remove apenas o diretório que está vazio. Assim como no exemplo anterior, você deve usar o comando rm -r para remover um diretório que contenha conteúdo.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host Documents<span class="o">]</span>$ <span class="nb">pwd</span>
/home/student/Documents
<span class="o">[</span>user@host Documents<span class="o">]</span>$ rmdir ProjectY
<span class="o">[</span>user@host Documents<span class="o">]</span>$ rmdir ProjectX
rmdir: failed to remove <span class="sb">`</span>ProjectX<span class="err">&#39;</span>: Directory not empty
<span class="o">[</span>user@host Documents<span class="o">]</span>$ rm -r ProjectX
<span class="o">[</span>user@host Documents<span class="o">]</span>$ ls -lR
.:
total <span class="m">0</span>
<span class="o">[</span>user@host Documents<span class="o">]</span>$
</code></pre></div><p>O comando rm sem opções não pode remover um diretório vazio. Você deve usar os comandos rmdir, rm -d (que é equivalente a rmdir) ou rm -r.</p>
<h2 id="criação-de-links-entre-arquivos">Criação de links entre arquivos</h2>
<p>É possível criar vários nomes que apontam para o mesmo arquivo. Existem duas maneiras de fazer isso: criando um link físico para o arquivo ou criando um link simbólico (às vezes chamado de ligação simbólica) para o arquivo. Cada um tem suas vantagens e desvantagens.</p>
<h2 id="criação-de-links-físicos">Criação de links físicos</h2>
<p>Todo arquivo inicia com um único link físico, desde seu nome inicial até os dados no sistema de arquivos. Quando você cria um novo link físico para um arquivo, cria outro nome que aponta para os mesmos dados. O novo link físico age exatamente como o nome do arquivo original. Uma vez criado, você não verá diferença entre o novo link físico e o nome original do arquivo.</p>
<p>Você pode descobrir se um arquivo tem vários links físicos com o comando ls -l. Uma das coisas que ele relata é a contagem de links de cada arquivo, o número de links físicos que o arquivo possui.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nb">pwd</span>
/home/user
<span class="o">[</span>user@host ~<span class="o">]</span>$ ls -l newfile.txt
-rw-r--r--. <span class="m">1</span> user user <span class="m">0</span> Mar <span class="m">11</span> 19:19 newfile.txt
</code></pre></div><p>No exemplo anterior, a contagem de links de newfile.txt é 1. Ele tem exatamente um caminho absoluto, que é /home/user/newfile.txt .</p>
<p>Você pode usar o comando ln para criar um novo link físico (outro nome) que aponte para um arquivo existente. O comando precisa de pelo menos dois argumentos, um caminho para o arquivo existente e o caminho para o link físico que você deseja criar.</p>
<p>O exemplo a seguir cria um link físico chamado newfile-link2.txt para o arquivo existente newfile.txt no diretório /tmp.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ ln newfile.txt /tmp/newfile-hlink2.txt
<span class="o">[</span>user@host ~<span class="o">]</span>$ ls -l newfile.txt /tmp/newfile-hlink2.txt
-rw-rw-r--. <span class="m">2</span> user user <span class="m">12</span> Mar <span class="m">11</span> 19:19 newfile.txt
-rw-rw-r--. <span class="m">2</span> user user <span class="m">12</span> Mar <span class="m">11</span> 19:19 /tmp/newfile-hlink2.txt
</code></pre></div><p>Se você desejar descobrir se dois arquivos são links físicos um do outro, uma maneira é usar a opção -i com o comando ls para listar o número de inode dos arquivos. Se os arquivos estiverem no mesmo sistema de arquivos (discutido a seguir) e seus números de inode forem os mesmos, os arquivos são links físicos apontando para os mesmos dados.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ ls -il newfile.txt /tmp/newfile-hlink2.txt
<span class="m">8924107</span> -rw-rw-r--. <span class="m">2</span> user user <span class="m">12</span> Mar <span class="m">11</span> 19:19 newfile.txt
<span class="m">8924107</span> -rw-rw-r--. <span class="m">2</span> user user <span class="m">12</span> Mar <span class="m">11</span> 19:19 /tmp/newfile-hlink2.txt
</code></pre></div><h2 id="importante-7">Importante</h2>
<p>Todos os links físicos que fazem referência ao mesmo arquivo terão as mesmas permissões, contagem de links, propriedade de usuário e grupo, carimbos de data e hora e conteúdo de arquivo. Se uma dessas informações for alterada em um link físico, todos os outros links físicos que apontem para o mesmo arquivo também exibirão a nova informação. Isso ocorre porque cada link físico aponta para os mesmos dados no dispositivo de armazenamento.</p>
<p>Mesmo que o arquivo original seja excluído, o conteúdo do arquivo ainda estará disponível, desde que pelo menos um link físico exista. Os dados só são excluídos do armazenamento quando o último link físico é excluído.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ rm -f newfile.txt
<span class="o">[</span>user@host ~<span class="o">]</span>$ ls -l /tmp/newfile-hlink2.txt
-rw-rw-r--. <span class="m">1</span> user user <span class="m">12</span> Mar <span class="m">11</span> 19:19 /tmp/newfile-hlink2.txt
<span class="o">[</span>user@host ~<span class="o">]</span>$ cat /tmp/newfile-hlink2.txt
Hello World
</code></pre></div><h2 id="limitações-de-links-físicos">Limitações de links físicos</h2>
<p>Os links físicos têm algumas limitações. Em primeiro lugar, os links físicos só podem ser usados com arquivos regulares. Você não pode usar ln para criar um link físico para um diretório ou arquivo especial.</p>
<p>Em segundo lugar, os links físicos só podem ser usados se ambos os arquivos estiverem no mesmo sistema de arquivos. A hierarquia do sistema de arquivos pode ser composta de vários dispositivos de armazenamento. Dependendo da configuração do sistema, quando você mudar para um novo diretório, esse diretório e seu conteúdo poderão ser armazenados em um sistema de arquivos diferente.</p>
<p>Você pode usar o comando df para listar os diretórios que estão em sistemas de arquivos diferentes. Por exemplo, você pode ver a saída desta maneira:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ df
Filesystem                   1K-blocks    Used Available Use% Mounted on
devtmpfs                        <span class="m">886788</span>       <span class="m">0</span>    <span class="m">886788</span>   0% /dev
tmpfs                           <span class="m">902108</span>       <span class="m">0</span>    <span class="m">902108</span>   0% /dev/shm
tmpfs                           <span class="m">902108</span>    <span class="m">8696</span>    <span class="m">893412</span>   1% /run
tmpfs                           <span class="m">902108</span>       <span class="m">0</span>    <span class="m">902108</span>   0% /sys/fs/cgroup
/dev/mapper/rhel_rhel8--root  <span class="m">10258432</span> <span class="m">1630460</span>   <span class="m">8627972</span>  16% /
/dev/sda1                      <span class="m">1038336</span>  <span class="m">167128</span>    <span class="m">871208</span>  17% /boot
tmpfs                           <span class="m">180420</span>       <span class="m">0</span>    <span class="m">180420</span>   0% /run/user/1000
<span class="o">[</span>user@host ~<span class="o">]</span>$ 
</code></pre></div><p>Arquivos em dois diretórios &ldquo;montados em&rdquo; diferentes e seus subdiretórios estão em sistemas de arquivos diferentes. (A correspondência mais específica vence.) Assim, no sistema deste exemplo, você pode criar um link físico entre /var/tmp/link1 e /home/user/file porque ambos são subdiretórios de / mas não de qualquer outro diretório na lista. No entanto, você não pode criar um link físico entre /boot/test/badlink e /home/user/file porque o primeiro arquivo está em um subdiretório de /boot (na lista &ldquo;montado em&rdquo;) e o segundo arquivo não.</p>
<h2 id="criação-de-softlinks">Criação de softlinks</h2>
<p>O comando ln -s cria um softlink, também chamado de &ldquo;link simbólico&rdquo;. Um link simbólico não é um arquivo normal, mas um tipo especial de arquivo que aponta para outro arquivo ou diretório existente.</p>
<p>Os links simbólicos têm algumas vantagens sobre links físicos:</p>
<p>=&gt; Eles podem vincular dois arquivos em diferentes sistemas de arquivos.</p>
<p>=&gt; Eles podem apontar para um diretório ou arquivo especial, não apenas um arquivo comum.</p>
<p>No exemplo a seguir, o comando ln -s é usado para criar um novo link flexível para o arquivo existente /home/user/newfile-link2.txt que será nomeado /tmp/newfile-symlink.txt.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ ln -s /home/user/newfile-link2.txt /tmp/newfile-symlink.txt
<span class="o">[</span>user@host ~<span class="o">]</span>$ ls -l newfile-link2.txt /tmp/newfile-symlink.txt
-rw-rw-r--. <span class="m">1</span> user user <span class="m">12</span> Mar <span class="m">11</span> 19:19 newfile-link2.txt
lrwxrwxrwx. <span class="m">1</span> user user <span class="m">11</span> Mar <span class="m">11</span> 20:59 /tmp/newfile-symlink.txt -&gt; /home/user/newfile-link2.txt
<span class="o">[</span>user@host ~<span class="o">]</span>$ cat /tmp/newfile-symlink.txt
Soft Hello World
</code></pre></div><p>No exemplo anterior, o primeiro caractere da listagem longa para /tmp/newfile-symlink.txt é l, em vez de -. Isso indica que o arquivo é um link simbólico e não um arquivo normal. (Um d indicaria que o arquivo é um diretório.)</p>
<p>Quando o arquivo regular original é excluído, o link simbólico continua apontando para o arquivo, mas o destino some. Um link simbólico que esteja apontando para um arquivo ausente é denominado &ldquo;link simbólico pendente&rdquo;.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ rm -f newfile-link2.txt
<span class="o">[</span>user@host ~<span class="o">]</span>$ ls -l /tmp/newfile-symlink.txt
lrwxrwxrwx. <span class="m">1</span> user user <span class="m">11</span> Mar <span class="m">11</span> 20:59 /tmp/newfile-symlink.txt -&gt; /home/user/newfile-link2.txt
<span class="o">[</span>user@host ~<span class="o">]</span>$ cat /tmp/newfile-symlink.txt
cat: /tmp/newfile-symlink.txt: No such file or directory
</code></pre></div><p>Importante</p>
<p>Um efeito colateral do link simbólico pendente no exemplo anterior é que, se você criar posteriormente um novo arquivo com o mesmo nome do arquivo excluído (/home/user/newfile-link2.txt), o link não estará mais &ldquo;pendurado&rdquo; e apontará para o novo arquivo.</p>
<p>Os links físicos não funcionam assim. Se você excluir um link físico e, em seguida, usar ferramentas normais ( ao invés de ln) para criar um novo arquivo com o mesmo nome, o novo arquivo não será vinculado ao arquivo antigo.</p>
<p>Uma maneira de comparar links físicos e links simbólicos que pode ajudar você a entender como eles funcionam:</p>
<p>=&gt; Um link físico aponta um nome para dados em um dispositivo de armazenamento</p>
<p>=&gt; Um link simbólico aponta um nome para outro nome, que aponta para dados em um dispositivo de armazenamento</p>
<p>Um link simbólico pode apontar para um diretório. Nesse caso, o link simbólico atuará como um diretório. Alterar para o link simbólico com cd fará com que o diretório de trabalho atual seja o diretório vinculado. Algumas ferramentas podem acompanhar o fato de você ter seguido um link simbólico para chegar lá. Por exemplo, por padrão cd atualizará seu diretório de trabalho atual usando o nome do link simbólico, em vez do nome do diretório real. (Existe uma opção, -P, que o atualizará com o nome do diretório real.)</p>
<p>No exemplo a seguir, um link simbólico denominado /home/user/configfiles é criado que aponta para o diretório /etc.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ ln -s /etc /home/user/configfiles
<span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nb">cd</span> /home/user/configfiles
<span class="o">[</span>user@host configfiles<span class="o">]</span>$ <span class="nb">pwd</span>
/home/user/configfiles
</code></pre></div><h2 id="correspondência-de-nomes-de-arquivos-com-expansões-de-shell">Correspondência de nomes de arquivos com expansões de shell</h2>
<p>O shell Bash apresenta várias maneiras de expandir uma linha de comando, incluindo a correspondência de padrões, a expansão de diretório pessoal, a expansão de string e a substituição de variável. Talvez a mais poderosa delas seja a capacidade de correspondência de nome de caminhos, historicamente chamada de globbing. O recurso de globbing do Bash, por vezes chamado de “wildcards”, facilita o gerenciamento de grandes números de arquivos. Ao usar metacaracteres que se “expandem” para corresponder a nomes de caminho e de arquivo que são procurados, os comandos são executados em um conjunto específico de arquivos de uma só vez.</p>
<p>Correspondência de padrões</p>
<p>Globbing é uma operação de análise de comandos do shell que expande um padrão de caracteres curinga em uma lista de nomes de caminho correspondentes. Metacaracteres de linha de comando são substituídos pela lista de correspondência antes da execução do comando. Os padrões que não retornam correspondências exibem a solicitação de padrão original como texto literal. Os itens a seguir são metacaracteres e classes de padrões comuns.</p>
<p>Tabela 3.3. Tabela de metacaracteres e correspondências</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">* <span class="o">=</span>&gt;  Qualquer string com zero ou mais caracteres. 

? <span class="o">=</span>&gt; Qualquer caractere único. 


<span class="o">[</span>abc...<span class="o">]</span> <span class="o">=</span>&gt; Qualquer caractere na classe entre colchetes. 

<span class="o">[</span>!abc...<span class="o">]</span> <span class="o">=</span>&gt; Qualquer caractere que não esteja na classe entre colchetes. 

<span class="o">[</span>^abc...<span class="o">]</span> <span class="o">=</span>&gt; Qualquer caractere que não esteja na classe entre colchetes. 

<span class="o">[[</span>:alpha:<span class="o">]]</span> <span class="o">=</span>&gt; Qualquer caractere alfabético. 

<span class="o">[[</span>:lower:<span class="o">]]</span> <span class="o">=</span>&gt; Qualquer caractere em minúsculas.

<span class="o">[[</span>:upper:<span class="o">]]</span> <span class="o">=</span>&gt; Qualquer caractere em maiúsculas. 

<span class="o">[[</span>:alnum:<span class="o">]]</span> <span class="o">=</span>&gt; Qualquer caractere alfabético ou numérico. 

<span class="o">[[</span>:punct:<span class="o">]]</span> <span class="o">=</span>&gt; Qualquer caractere imprimível que não seja alfanumérico nem um espaço. 

<span class="o">[[</span>:digit:<span class="o">]]</span> <span class="o">=</span>&gt; Qualquer dígito único de <span class="m">0</span> a 9. 

<span class="o">[[</span>:space:<span class="o">]]</span> <span class="o">=</span>&gt; Qualquer caractere de espaço único. Isso pode incluir recuos, novas linhas, retornos, avanços de página ou espaços. 
</code></pre></div><p>Para os próximos exemplos, digamos que você executou os comandos a seguir para criar alguns arquivos de amostra.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ mkdir glob<span class="p">;</span> <span class="nb">cd</span> glob
<span class="o">[</span>user@host glob<span class="o">]</span>$ touch alfa bravo charlie delta <span class="nb">echo</span> able baker cast dog easy
<span class="o">[</span>user@host glob<span class="o">]</span>$ ls
able  alfa  baker  bravo  cast  charlie  delta  dog  easy  <span class="nb">echo</span>
<span class="o">[</span>user@host glob<span class="o">]</span>$ 
</code></pre></div><p>O primeiro exemplo usará combinações de padrão simples com os caracteres asterisco * e ponto de interrogação &lsquo;?&rsquo; e uma classe de caracteres para corresponder a alguns desses nomes de arquivo.</p>
<h2 id="expansão-de-til">Expansão de til</h2>
<p>O caractere til &lsquo;~&rsquo; corresponde ao diretório pessoal do usuário atual. Se uma string diferente de uma barra &lsquo;/&rsquo; for iniciada, o shell interpretará a string até essa barra como um nome de usuário, se houver uma correspondência, e substituirá a cadeia pelo caminho absoluto para o diretório pessoal desse usuário. Se nenhum nome de usuário for correspondente, um til real seguido da string será usado.</p>
<p>No exemplo a seguir, o comando echo é usado para exibir o valor do caractere til. O comando echo também pode ser usado para exibir os valores de chaves e caracteres de expansão de variáveis, entre outros.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host glob<span class="o">]</span>$ <span class="nb">echo</span> ~root
/root
<span class="o">[</span>user@host glob<span class="o">]</span>$ <span class="nb">echo</span> ~user
/home/user
<span class="o">[</span>user@host glob<span class="o">]</span>$ <span class="nb">echo</span> ~/glob
/home/user/glob
<span class="o">[</span>user@host glob<span class="o">]</span>$ 
</code></pre></div><h2 id="expansão-de-chave">Expansão de chave</h2>
<p>A expansão de chave é usada para gerar strings de caracteres distintas. As chaves contêm uma lista de strings separadas por vírgula ou uma expressão de sequência. O resultado inclui o texto anterior ou o posterior à definição de chave. As expansões de chave podem ser aninhadas uma dentro da outra. Além disso, a sintaxe de dois pontos (..) é expandida para uma sequência tal que {m..p} será expandido para m n o p.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host glob<span class="o">]</span>$ <span class="nb">echo</span> <span class="o">{</span>Sunday,Monday,Tuesday,Wednesday<span class="o">}</span>.log
Sunday.log Monday.log Tuesday.log Wednesday.log
<span class="o">[</span>user@host glob<span class="o">]</span>$ <span class="nb">echo</span> file<span class="o">{</span>1..3<span class="o">}</span>.txt
file1.txt file2.txt file3.txt
<span class="o">[</span>user@host glob<span class="o">]</span>$ <span class="nb">echo</span> file<span class="o">{</span>a..c<span class="o">}</span>.txt
filea.txt fileb.txt filec.txt
<span class="o">[</span>user@host glob<span class="o">]</span>$ <span class="nb">echo</span> file<span class="o">{</span>a,b<span class="o">}{</span>1,2<span class="o">}</span>.txt
filea1.txt filea2.txt fileb1.txt fileb2.txt
<span class="o">[</span>user@host glob<span class="o">]</span>$ <span class="nb">echo</span> file<span class="o">{</span>a<span class="o">{</span>1,2<span class="o">}</span>,b,c<span class="o">}</span>.txt
filea1.txt filea2.txt fileb.txt filec.txt
<span class="o">[</span>user@host glob<span class="o">]</span>$ 
</code></pre></div><p>Um uso prático da expansão de chaves é criar rapidamente vários arquivos ou diretórios.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host glob<span class="o">]</span>$ mkdir ../RHEL<span class="o">{</span>6,7,8<span class="o">}</span>
<span class="o">[</span>user@host glob<span class="o">]</span>$ ls ../RHEL*
RHEL6 RHEL7 RHEL8
<span class="o">[</span>user@host glob<span class="o">]</span>$ 
</code></pre></div><h2 id="expansão-variável">Expansão variável</h2>
<p>Uma variável age como um contêiner nomeado que pode armazenar um valor na memória. As variáveis facilitam o acesso e modificam os dados armazenados a partir da linha de comando ou dentro de um script de shell.</p>
<p>Você pode atribuir dados como um valor a uma variável usando a seguinte sintaxe:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nv">VARIABLENAME</span><span class="o">=</span>value
</code></pre></div><p>Você pode usar a expansão variável para converter o nome da variável para o valor na linha de comando. Se uma string começar com um cifrão ($), o shell tentará usar o restante dessa cadeia como um nome de variável e o substituirá por qualquer valor que a variável tenha.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nv">USERNAME</span><span class="o">=</span>operator
<span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nb">echo</span> <span class="nv">$USERNAME</span>
operator
</code></pre></div><p>Para ajudar a evitar erros devido a outras expansões de shell, você pode colocar o nome da variável entre chaves, por exemplo ${VARIABLENAME} .</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nv">USERNAME</span><span class="o">=</span>operator
<span class="o">[</span>user@host ~<span class="o">]</span>$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">USERNAME</span><span class="si">}</span>
operator
</code></pre></div><p>As variáveis do shell e as formas de usá-las serão abordadas com mais profundidade posteriormente neste curso.</p>
<h2 id="substituição-de-comandos">Substituição de comandos</h2>
<p>A substituição de comandos permite que a saída de um comando substitua o próprio comando. A substituição de comandos ocorre quando um comando é colocado entre parênteses e precedido por um cifrão ($). A forma $(command) pode aninhar várias expansões de comandos, uma dentro da outra.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host glob<span class="o">]</span>$ <span class="nb">echo</span> Today is <span class="k">$(</span>date +%A<span class="k">)</span>.
Today is Wednesday.
<span class="o">[</span>user@host glob<span class="o">]</span>$ <span class="nb">echo</span> The <span class="nb">time</span> is <span class="k">$(</span>date +%M<span class="k">)</span> minutes past <span class="k">$(</span>date +%l%p<span class="k">)</span>.
The <span class="nb">time</span> is <span class="m">26</span> minutes past 11AM.
<span class="o">[</span>user@host glob<span class="o">]</span>$ 
</code></pre></div><h2 id="proteção-de-argumentos-da-expansão">Proteção de argumentos da expansão</h2>
<p>Vários caracteres têm significado especial no shell Bash. Para evitar que o shell execute expansões de shell em partes de sua linha de comando, você pode usar aspas e escapes em caracteres e strings.</p>
<p>A barra invertida () é um caractere de escape no shell Bash. Ela protegerá contra expansão o caractere que vem imediatamente depois.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host glob<span class="o">]</span>$ <span class="nb">echo</span> The value of <span class="nv">$HOME</span> is your home directory.
The value of /home/user is your home directory.
<span class="o">[</span>user@host glob<span class="o">]</span>$ <span class="nb">echo</span> The value of <span class="se">\$</span>HOME is your home directory.
The value of <span class="nv">$HOME</span> is your home directory.
<span class="o">[</span>user@host glob<span class="o">]</span>$ 
</code></pre></div><p>No exemplo anterior, proteger o cifrão de expansão fez com que o Bash o tratasse como um caractere regular e não executou a expansão de variável em $HOME .</p>
<p>Para proteger strings mais longas, aspas simples (') ou duplas (&quot;) são usadas para delimitar strings. Elas têm efeitos ligeiramente diferentes. As aspas simples param toda a expansão do shell. As aspas duplas param a maior parte da expansão do shell.</p>
<p>Use aspas duplas para suprimir globbing e a expansão do shell, mas ainda permitir substituição de comandos e de variáveis.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host glob<span class="o">]</span>$ <span class="nv">myhost</span><span class="o">=</span><span class="k">$(</span>hostname -s<span class="k">)</span><span class="p">;</span> <span class="nb">echo</span> <span class="nv">$myhost</span>
host
<span class="o">[</span>user@host glob<span class="o">]</span>$ <span class="nb">echo</span> <span class="s2">&#34;***** hostname is </span><span class="si">${</span><span class="nv">myhost</span><span class="si">}</span><span class="s2"> *****&#34;</span>
***** hostname is host *****
<span class="o">[</span>user@host glob<span class="o">]</span>$ 
</code></pre></div><p>Use aspas simples para interpretar todo o texto literalmente.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>user@host glob<span class="o">]</span>$ <span class="nb">echo</span> <span class="s2">&#34;Will variable </span><span class="nv">$myhost</span><span class="s2"> evaluate to </span><span class="k">$(</span>hostname -s<span class="k">)</span><span class="s2">?&#34;</span>
Will variable host evaluate to host?
<span class="o">[</span>user@host glob<span class="o">]</span>$ <span class="nb">echo</span> <span class="s1">&#39;Will variable $myhost evaluate to $(hostname -s)?&#39;</span>
Will variable <span class="nv">$myhost</span> evaluate to <span class="k">$(</span>hostname -s<span class="k">)</span>?
<span class="o">[</span>user@host glob<span class="o">]</span>$ 
</code></pre></div><p>Neste capítulo, você aprendeu que:</p>
<p>Os arquivos em um sistema Linux são organizados em uma única árvore de diretório invertida, conhecida como hierarquia do sistema de arquivos.</p>
<p>Os caminhos absolutos começam com um / e especificam a localização de um arquivo na hierarquia do sistema de arquivos.</p>
<p>Os caminhos relativos não começam com um / e especificam a localização de um arquivo em relação ao diretório de trabalho atual.</p>
<p>Cinco comandos principais são usados para gerenciar arquivos: mkdir , rmdir , cp , mv e rm .</p>
<p>Os links físicos e os links simbólicos são maneiras diferentes de ter vários nomes de arquivos apontando para os mesmos dados.</p>
<p>O shell Bash fornece recursos de correspondência, expansão e substituição de padrões para ajudar você a executar comandos de maneira eficiente.</p>
<h2 id="capítulo-4-ajuda-no-red-hat-enterprise-linux">Capítulo 4. Ajuda no Red Hat Enterprise Linux</h2>

</main>
    <footer>
  

</footer>
  </body>
</html>
